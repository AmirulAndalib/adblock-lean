#!/bin/sh /etc/rc.common
# shellcheck disable=SC3043,SC1091,SC3001,SC2018,SC2019,SC3020,SC3003,SC2181,SC2254,SC1090

# adblock-lean - super simple and lightweight adblocking for OpenWrt

# Project homepage: https://github.com/lynxthecat/adblock-lean

# Authors: @Lynx and @Wizballs (OpenWrt forum)
# Contributors: @antonk; @dave14305 (OpenWrt forum)

# global exit codes:
# 0 - Success
# 1 - Error
# 254 - Failed to acquire lock

# special variables for luci:
# luci_errors
# luci_good_line_count
# luci_dnsmasq_status
# luci_update_status
# luci_pid_action

# expects that the RPC script for luci UI is named specifically 'luci.adblock-lean'


LC_ALL=C
IFS='	 
'
default_IFS="${IFS}"

if [ -t 0 ]
then
	msgs_dest="/dev/tty"
else
	msgs_dest="/dev/null"
fi

PREFIX=/root/adblock-lean
abl_dir=/var/run/adblock-lean
tmp_abl_dir=/tmp/adblock-lean
config_file="${PREFIX}/config"

export PATH=/usr/sbin:/usr/bin:/sbin:/bin
export HOME=/root

START=99
STOP=4

EXTRA_COMMANDS="status pause resume gen_stats gen_config update"
EXTRA_HELP="	
adblock-lean custom commands:
	status		check dnsmasq and good line count of existing blocklist
	pause		pause adblock-lean
	resume		resume adblock-lean
	gen_stats	generate dnsmasq stats for system log
	gen_config	generate default config
	update		update adblock-lean to the latest version"


### UTILITY FUNCTIONS

# sets variables for colors
set_colors()
{
	set -- $(printf '\033[0;31m \033[0;32m \033[1;34m \033[1;33m \033[0;35m \033[0m')
	red="${1}" green="${2}" blue="${3}" yellow="${4}" purple="${5}" n_c="${6}"
}

get_file_size_human()
{
	bytes2human "$(du -b "$1" | awk '{print $1}')"
}

# converts unsigned integer to [xB|xKiB|xMiB|xGiB|xTiB]
# if result is not an integer, outputs up to 2 digits after decimal point
# 1 - int
bytes2human()
{
	local i=${1:-0} s=0 d=0 m=1024 fp='' S=''
	case "$i" in *[!0-9]*) reg_failure "bytes2human: Invalid unsigned integer '$i'."; return 1; esac
	for S in B KiB MiB GiB TiB; do
		[ $((i > m && s < 4)) = 0 ] && break
		d=$i i=$((i/m)) s=$((s+1))
	done
	d=$((d % m * 100 / m))
	case $d in
		0) printf "%s %s\n" "$i" "$S"; return ;;
		[1-9]) fp="02" ;;
		*0) d=${d%0}; fp="01"
	esac
	printf "%s.%${fp}d %s\n" "$i" "$d" "$S"
}

int2human()
{
	case "$1" in *[!0-9]*) reg_failure "int2human: Invalid unsigned integer '$1'."; return 1; esac
	local in_num="$1" out_num=''

	# strip leading zeroes
	while :
	do
		case "$in_num" in
			0?*) in_num="${in_num#0}" ;;
			*) break
		esac
	done

	while :
	do
		case "$in_num" in 
			????*)
				out_num=",${in_num#"${in_num%???}"}${out_num}"
				in_num="${in_num%???}" ;;
			*) break
		esac
	done
	out_num="${in_num}${out_num}"

	echo "${out_num#,}"
}

get_uptime_ms()
{
	read -r uptime_ms _ < /proc/uptime
	printf "${uptime_ms%.*}${uptime_ms#*.}0"
}

get_elapsed_time_str()
{
	# To use, first set initial uptime: initial_uptime_ms=$(get_uptime_ms)
	# Then call this function to get elapsed time string at desired intervals, e.g.:
	# printf "Elapsed time: $(get_elapsed_time_str)\n"

	elapsed_time_s=$(( ($(get_uptime_ms)-${initial_uptime_ms:-$(get_uptime_ms)})/1000 ))
	printf '%dm:%ds' $((elapsed_time_s/60)) $((elapsed_time_s%60))
}

print_msg()
{
	printf '%s\n' "${1}" > "$msgs_dest"
}

log_msg()
{
	local msg='' msg_prefix='' _arg err_l=info color=

	for _arg in "$@"; do
		case "${_arg}" in
			"-err") err_l=err color="${red}" msg_prefix="Error: " ;;
			"-warn") err_l=warn color="${yellow}" msg_prefix="Warning: " ;;
			-blue|-red|-green|-purple|-yellow) eval "color=\"\${${_arg#-}}\"" ;;
			'') ;;
			*) msg="${msg}${msg_prefix}${_arg} "
		esac
	done
	msg="${msg% }"

	print_msg "${color}${msg}${n_c}"
	logger -t adblock-lean -p user."${err_l}" "${msg}"
}

try_mv()
{
	[ -z "${1}" ] || [ -z "${2}" ] && { reg_failure "try_mv(): bad arguments."; return 1; }
	mv -f "${1}" "${2}" || { reg_failure "Failed to rename '${1}'."; return 1; }
	:
}

# asks the user to pick an option
# 1 - input in the format 'a|b|c'
# output via $REPLY
pick_opt() {
	update_pid_action "Waiting for user input in console" || return 1
	while :; do
		printf %s "$1: " 1>${msgs_dest}
		read -r REPLY
		case "$REPLY" in *[!A-Za-z0-9]*) printf '\n%s\n\n' "Please enter $1" 1>${msgs_dest}; continue; esac
		eval "case \"$REPLY\" in 
				$1) return 0 ;;
				*) printf '\n%s\n\n' \"Please enter $1\" 1>${msgs_dest}
			esac"
	done
}


### HELPER FUNCTIONS

print_def_config()
{
	cat <<-EOT
	# adblock-lean configuration options
	# values must be enclosed in double-quotes
	# comments must start at newline or inline after the closing double-quote

	# One or more dnsmasq blocklist urls separated by spaces
	blocklist_urls="https://raw.githubusercontent.com/hagezi/dns-blocklists/main/dnsmasq/pro.txt https://raw.githubusercontent.com/hagezi/dns-blocklists/main/dnsmasq/tif.mini.txt"

	# One or more allowlist urls separated by spaces
	allowlist_urls=""

	# Path to optional local allowlist/blocklist files in the form:
	# site1.com
	# site2.com
	local_allowlist_path="${PREFIX}/allowlist"
	local_blocklist_path="${PREFIX}/blocklist"

	# Mininum number of lines of any individual downloaded part
	min_blocklist_part_line_count="1"
	min_allowlist_part_line_count="1"
	# Maximum size of any individual downloaded blocklist part
	max_file_part_size_KB="20000"
	# Maximum total size of combined, processed blocklist
	max_blocklist_file_size_KB="30000"
	# Minimum number of good lines in final postprocessed blocklist
	min_good_line_count="100000"

	# compress blocklist to save memory once blocklist has been loaded - enable (1) or disable (0)
	compress_blocklist="1"

	# restart dnsmasq if previous blocklist was extracted and before generation of
	# new blocklist thereby to free up memory during generaiton of new blocklist - enable (1) or disable (0)
	initial_dnsmasq_restart="0"

	# Maximum number of download retries
	max_download_retries="3"

	# List part failed action:
	# This option applies to blocklist/allowlist parts which failed to download or couldn't pass validation checks
	# SKIP - skip failed blocklist file part and continue blocklist generation
	# STOP - stop blocklist generation (and fall back to previous blocklist if available)
	list_part_failed_action="SKIP"

	# If a path to custom script is specified and that script defines functions 'report_success()' and 'report_failure()'',
	# one of these functions will be executed when adblock-lean completes the execution of some commands,
	# with the success or failure message passed in first argument
	# report_success() is only executed upon completion of the 'start' command
	custom_script=""

	# Start delay in seconds when service is started from system boot
	boot_start_delay_s="120"

	EOT
}

# validate config and assign to variables
#
# 1 - path to file
#
# return codes:
# 0 - Success
# 1 - Error
# 2 - Unexpected, missing or legacy-formatted (no double quotes) entries found
parse_config() {
	inval_e()
	{
		IFS="${default_IFS}"
		reg_failure "Invalid entry '$entry' in config."
	}

	# Following 2 function are needed to minimize ugly hacks and tinkering inside eval
	# shellcheck disable=SC2317
	parse_entry()
	{
		val=${entry#"${key}="}

		# Following 'case' is a temporarily solution to allow easy config migration - remove a few months from now (Aug 2024)
		case "${entry}" in
			"compress_blocklist="?" #"*|"initial_dnsmasq_restart="?" #"*)
				legacy_entries="${legacy_entries}${entry}"$'\n'; legacy_keys="${legacy_keys}${key} "
				test_keys="${test_keys%%"${key}|"*}${test_keys#*"${key}|"}"
				val=${val%% *}
				return 0
		esac

		case "${val}" in
			\"*\"*\") inval_e; return 1 ;; # do not allow more than 2 double-quote marks
			\"*\"*) ;;
			*\"*) inval_e; return 1 ;; # do not allow 1 double-quote mark
			*"#"*) inval_e; return 1 ;; # do not allow in-line comments without double-quote marks
			*) legacy_entries="${legacy_entries}${entry}"$'\n'; legacy_keys="${legacy_keys}${key} "
		esac
		val=${val#\"}
		val=${val%\"*} # throw away everything after the 2nd double-quote mark
		test_keys="${test_keys%%"${key}|"*}${test_keys#*"${key}|"}" # remove current key from test_keys
	}

	add_unexp_entry()
	{
		unexp_keys="${unexp_keys}${key} "
		unexp_entries="${unexp_entries}${entry}"$'\n'
	}

	local def_config bad_config='' curr_config test_keys entry key val

	[ -z "${1}" ] && { reg_failure "parse_config(): no file specified."; return 1; }

	[ ! -f "${1}" ] && { reg_failure "Config file '${1}' not found."; return 1; }

	# extract entries from default config
	def_config="$(print_def_config | sed "${sed_conf_san_exp}")"

	# extract keys from default config, convert to '|' separated list
	# 'dummy|' is needed to avoid errors in eval
	test_keys="dummy|$(print_def_config | sed "${sed_conf_san_exp}"'s/=.*//' | tr '\n' '|')"

	# read and sanitize current config
	curr_config="$(sed "${sed_conf_san_exp}" "${1}")" || { reg_failure "Failed to read the config file '${1}'."; return 1; }

	local IFS=$'\n'
	for entry in ${curr_config}; do
		case ${entry} in
			*?=*) ;;
			*) { inval_e; return 1; } ;;
		esac
		key="${entry%%=*}"
		case "${key}" in *[!A-Za-z0-9_]*) inval_e; return 1; esac
		# check if the key is in the default keys list, assign value to var if so
		eval "case \"${key}\" in
				${test_keys%|})
					parse_entry || return 1
					${key}"='${val}'" ;;
				*) add_unexp_entry
			esac"
	done

	IFS="${default_IFS}"

	test_keys=${test_keys#dummy|}
	if [ -n "${test_keys}" ]
	then
		missing_entries="$(printf %s "${def_config}" | grep -E "^(${test_keys%|})=")"
		missing_keys="$(printf %s "${test_keys}" | tr '|' ' ')"
	fi

	if [ -n "${unexp_entries}" ]
	then
		echo
		reg_failure "Unexpected keys in config: '${unexp_keys% }'."
		print_msg "Corresponding config entries:"
		print_msg "${unexp_entries%$'\n'}"
		bad_config=1
	fi

	if [ -n "${missing_keys% }" ]
	then
		echo
		reg_failure "Missing keys in config: '${missing_keys% }'."
		print_msg "Corresponding default config entries:"
		print_msg "${missing_entries}"
		bad_config=1
	fi

	if [ -n "${legacy_entries}" ]
	then
		echo
		reg_failure "Config entries for keys '${legacy_keys% }' are in legacy format (missing double-quotes)."
		print_msg "The following config entries must be converted to the new config format:"
		print_msg "${legacy_entries%$'\n'}"
		bad_config=1
	fi

	[ -n "${bad_config}" ] && return 2
	:
}

load_config() {
	local missing_keys='' missing_entries='' unexp_keys='' unexp_entries='' legacy_keys='' legacy_entries='' fixed_config='' key val line fix cnt val_res \
		rm_unexp add_missing conv_legacy temp_config_f="${tmp_abl_dir}/fix-config.tmp" \
		tip_msg="Fix your config file '${config_file}' or generate default config using 'service adblock-lean gen_config'."

	# validate config and assign to variables
	parse_config "${config_file}"

	case ${?} in
		0) return 0 ;;
		1) log_msg "${tip_msg}"; return 1 ;;
		2)
	esac

	[ "${msgs_dest}" != "/dev/tty" ] && { log_msg "${tip_msg}"; return 1; }

	[ -z "$unexp_keys" ] && [ -z "$missing_keys" ] && [ -z "$legacy_entries" ] &&
		{ reg_failure "Internal error when parsing config."; return 1; }

	[ -n "$unexp_keys" ] && rm_unexp="Remove unexpected entries from the config"
	[ -n "$missing_keys" ] && add_missing="Re-add missing config entries with default values"
	[ -n "$legacy_entries" ] && conv_legacy="Convert legacy config entries to the new format"

	echo
	print_msg "${blue}Perform following automatic changes?${n_c}"
	cnt=0
	for fix in "${rm_unexp}" "${add_missing}" "${conv_legacy}"
	do
		[ -z "${fix}" ] && continue
		cnt=$((cnt+1))
		print_msg "${cnt}. ${fix}"
	done
	pick_opt "y|n" || return 1
	[ "${REPLY}" = n ] && { log_msg "${tip_msg}"; return 1; }

	# recreate config from default while replacing values with values from the existing config
	fixed_config="$(
		IFS=$'\n'
		print_def_config | while read -r line
		do
			case ${line} in
				\#*|'') printf '%s\n' "${line}"; continue ;;
				*=*)
					key=${line%%=*}
					case " ${missing_keys}" in
						*" ${key} "*) printf '%s\n' "${line}"; continue ;;
						*)
							eval "val=\"\${${key}}\""
							printf '%s\n' "${key}=\"${val}\""
							continue
					esac
			esac
		done
	)"

	printf '%s\n' "${fixed_config}" > "${temp_config_f}" || return 1
	unset missing_keys missing_entries unexp_keys unexp_entries legacy_keys legacy_entries
	parse_config "${temp_config_f}"
	val_res=${?}
	rm -f "${temp_config_f}"
	[ "${val_res}" != 0 ] && { reg_failure "Failed to recreate the config."; log_msg "${tip_msg}"; return 1; }
	mkdir -p "${PREFIX}"
	write_config "${fixed_config}" || { rm -f "${temp_config_f}"; return 1; }

	:
}

# 1 - new config file contents
write_config()
{
	local tmp_config="${tmp_abl_dir}/write-config.tmp"

	[ -z "${1}" ] && { reg_failure "write_config(): no config passed."; return 1; }

	mkdir -p "${tmp_abl_dir}"
	printf '%s\n' "${1}" > "${tmp_config}" || { reg_failure "Failed to write to file '${tmp_config}'."; return 1; }

	echo
	log_msg "Saving new config file to '${config_file}'."
	try_mv "${tmp_config}" "${config_file}" && return 0
	rm -f "${tmp_config}"
	return 1
}

# return codes:
# 0 - running
# 1,2 - (reserved)
# 3 - paused
# 4 - stopped
get_abl_run_state()
{
	local f
	for f in "${dnsmasq_tmp_d}/.blocklist.gz" "${dnsmasq_tmp_d}/blocklist"
	do
		[ -f "${f}" ] && return 0
	done

	[ -f "${abl_dir}/prev_blocklist.gz" ] && return 3
	return 4
}

clean_dnsmasq_dir()
{
	rm -f "${dnsmasq_tmp_d}"/.blocklist.gz "${dnsmasq_tmp_d}"/blocklist "${dnsmasq_tmp_d}"/conf-script "${dnsmasq_tmp_d}"/.extract_blocklist
}

# exit with code ${1}
# if function 'abl_luci_exit' is defined, execute it before exit
cleanup_and_exit()
{
	trap - INT TERM EXIT
	[ -n "${cleanup_req}" ] && rm -rf "${abl_dir}"
	[ -n "${lock_req}" ] && rm_lock
	[ -z "${luci_sourced}" ] && [ -n "${failure_msg}" ] && [ -n "${custom_scr_sourced}" ] && command -v report_failure 1>/dev/null &&
		report_failure "${failure_msg}"
	[ -n "${luci_sourced}" ] && abl_luci_exit "${1}"
	exit "${1}"
}

reg_failure()
{
	log_msg -err "${1}"
	failure_msg="${failure_msg}${1}"$'\n'
	luci_errors="${failure_msg}"
}

log_success()
{
	log_msg "${1}"
	if [ -n "${custom_scr_sourced}" ] && command -v report_success 1>/dev/null
	then
		report_success "${1}"
	fi
}

try_export_existing_blocklist()
{
	export_existing_blocklist
	case ${?} in
		1) reg_failure "Failed to export the blocklist."; return 1 ;;
		2) return 2
	esac
	:	
}

check_blocklist_compression_support()
{
	if ! dnsmasq --help | grep -qe "--conf-script"
	then
		reg_failure "The version of dnsmasq installed on this system does not support blocklist compression."
		log_msg "Blocklist compression support in dnsmasq can be verified by checking the output of: dnsmasq --help | grep -e \"--conf-script\""
		log_msg "Either upgrade OpenWrt and/or dnsmasq to a newer version that supports blocklist compression or disable blocklist compression in config."
		return 1
	fi

	addnmount_str=$(uci get dhcp.@dnsmasq[0].addnmount 2> /dev/null)

	for addnmount_path in ${addnmount_str}
	do
		printf "%s" "$addnmount_path" | grep -qE "^/bin(/*|/busybox)?$" && return 0
	done

	reg_failure "No appropriate 'addnmount' entry in /etc/config/dhcp was identified."
	log_msg "This is leveraged to give dnsmasq access to busybox gunzip to extract compressed blocklist."
	log_msg "Add: \"list addnmount '/bin/busybox'\" to /etc/config/dhcp at the end of the dnsmasq section."
	log_msg "Or simply run this command: uci add_list dhcp.@dnsmasq[0].addnmount='/bin/busybox' && uci commit"
	log_msg "Either edit /etc/config/dhcp as described above or disable blocklist compression in config."
	return 1
}

cleanup_dl_status_files()
{
	rm -f "${abl_dir}/rogue_element" "${abl_dir}/dnsmasq_err" "${abl_dir}/uclient-fetch_err"
}

# ugly hack to compensate for 'wc -l' issue (subtract 1 if cnt>1)
# 1 - var name to fix the value of
fix_line_cnt()
{
	local cnt
	eval "cnt=\"\${${1}}\""
	case ${cnt} in
		''|0|1|*[!0-9]*) ;;
		*) eval "${1}=$((cnt-1))"
	esac
}

# 1 - list id
# 2 - list type (allowlist or blocklist)
# 3 - list URL
#
# return codes:
# 0 - Success
# 1 - General error (stop processing)
# 2 - Bad List (retry doesn't make sense)
# 3 - Download Failure (retry makes sense)
download_and_process_list_part()
{
	local list_id="${1}" list_type="${2}" list_url="${3}" me="download_and_process_list_part"
	local dest_file="${abl_dir}/${list_type}.${list_id}" compress='' convert_to_local='' \
		min_list_part_line_count='' list_part_size_B='' list_part_size_KB=''

	[ -z "${list_id}" ] && { reg_failure "${me}: No list id specified."; return 1; }
	case ${list_type} in
		allowlist) ;;
		blocklist)
			convert_to_local="; s/^\(address=\|server=\)/local=/"
			dest_file="${dest_file}.gz"
			compress=1 ;;
		*) reg_failure "${me}: Missing or invalid list type '${list_type}'"; return 1
	esac
	[ -z "${list_url}" ] && { reg_failure "${me}: no URL specified."; return 1; }

	eval "min_list_part_line_count=\"\${min_${list_type}_part_line_count}\""

	cleanup_dl_status_files

	reg_action "Downloading, checking and sanitizing new ${list_type} file part from: ${list_url}." || return 1
	uclient-fetch "${list_url}" -O- --timeout=3 2> "${abl_dir}/uclient-fetch_err" | 
	{ head -c "${max_file_part_size_KB}k"; cat 1>/dev/null; } |
	tee >(wc -c > "${abl_dir}/list_part_size_B") |
	# 1 Convert to lowercase; 2 Remove comment lines and trailing comments; 3 Remove trailing address hash, and all whitespace; 4 Convert to local=
	tr 'A-Z' 'a-z' | sed "s/#.*$//; s/^[ \t]*//; s/[ \t]*$//; /^$/d${convert_to_local}"'; $a' |
	if [ "${list_type}" = blocklist ] && [ "${use_allowlist}" = 1 ]
	then
		${awk_cmd} -F'/' 'NR==FNR { allow[$0]; next } { n=split($2,arr,"."); addr = arr[n]; \
			for ( i=n-1; i>=1; i-- ) { addr = arr[i] "." addr; if ( addr in allow ) next } } 1' "${abl_dir}/allowlist" -
	else
		cat
	fi |
	tee >(wc -l > "${abl_dir}/list_part_line_count") |
	tee >(sed -nE '\~^((local|server)=/[[:alnum:]*][[:alnum:]*_.-]+/$|bogus-nxdomain=[0-9.]+$|$)~d;p;:1 n;b1' > "${abl_dir}/rogue_element") |
	if [ -n "${compress}" ]
	then
		tee >(gzip > "${dest_file}")
	else
		tee "${dest_file}"
	fi |
	{ dnsmasq --test -C - 2> "${abl_dir}/dnsmasq_err" && rm -f "${abl_dir}/dnsmasq_err"; cat 1>/dev/null; }

	read -r list_part_size_B _ < "${abl_dir}/list_part_size_B" 2>/dev/null
	list_part_size_KB=$(( (list_part_size_B + 0) / 1024 ))
	list_part_size_human="$(bytes2human "${list_part_size_B:-0}")"
	read -r list_part_line_count _ < "${abl_dir}/list_part_line_count" 2>/dev/null
	: "${list_part_line_count:=0}"

	rm -f "${abl_dir}/list_part_size_B" "${abl_dir}/list_part_line_count"

	if [ "${list_part_size_KB}" -ge "${max_file_part_size_KB}" ]
	then
		reg_failure "Downloaded ${list_type} part size reached the maximum value set in config (${max_file_part_size_KB} KB)."
		log_msg "Consider either increasing this value in the config or removing the corresponding ${list_type} url."
		log_msg "Skipping ${list_type} part and continuing."
		rm -f "${dest_file}"
		return 2
	fi

	if ! grep -q "Download completed" "${abl_dir}/uclient-fetch_err"
	then
		rm -f "${dest_file}"
		reg_failure "Download of new ${list_type} file part from: ${list_url} failed."
		return 3
	fi

	if read -r rogue_element < "${abl_dir}/rogue_element"
	then
		rm -f "${dest_file}"
		log_msg -warn "Rogue element: '${rogue_element}' identified originating in ${list_type} file part from: ${list_url}."
		return 2
	fi
	rm -f "${abl_dir}/rogue_element"

	if [ -f "${abl_dir}/dnsmasq_err" ]
	then
		rm -f "${dest_file}"
		reg_failure "The dnsmasq --test on the ${list_type} part failed."
		log_msg "dnsmasq --test error:"
		log_msg "$(cat "${abl_dir}/dnsmasq_err")"
		return 2
	fi
	rm -f "${abl_dir}/dnsmasq_err"

	fix_line_cnt list_part_line_count
	if [ "${list_part_line_count}" -lt "${min_list_part_line_count}" ]
	then
		rm -f "${dest_file}"
		reg_failure "Downloaded ${list_type} part line count: $(int2human ${list_part_line_count}) less than configured minimum: $(int2human ${min_list_part_line_count})."
		return 3
	fi

	cleanup_dl_status_files
	log_msg "Processing of new ${list_type} part from: ${list_url} succeeded."
	log_msg "Downloaded file size: ${list_part_size_human}; sanitized line count: $(int2human ${list_part_line_count})."

	:
}

gen_list_parts()
{
	local list_type='' list_id list_line_count=0 list_part_line_count=0 and_compressing='' sed_expr list_urls list_url local_list_path

	for list_type in allowlist blocklist
	do
		case ${list_type} in
			allowlist) sed_expr="${sed_san_expr}"'; $a' ;;
			blocklist)
				sed_expr="${sed_san_expr}"'; s~.*~local=/&/~; $a'
				and_compressing=" and compressing"
		esac
		list_id=0

		rm -f "${abl_dir}/${list_type}"*

		# Local list
		echo
		eval "local_list_path=\"\${local_${list_type}_path}\""
		eval "list_urls=\"\${${list_type}_urls}\""

		if [ -s "${local_list_path}" ]
		then
			log_msg -blue "Found local ${list_type}. Sanitizing${and_compressing}."
			reg_action -nolog "Sanitizing${and_compressing} the local ${list_type}." || return 1
			# 1 Convert to lowercase; 2 Remove comment lines and trailing comments; 3 Remove trailing address hash, and all whitespace; 4 Add newline
			list_part_line_count="$(
				tr 'A-Z' 'a-z' < "${local_list_path}" | sed "${sed_expr}" |
				if [ "${list_type}" = blocklist ]
				then
					tee >(gzip > "${abl_dir}/blocklist.${list_id}.gz")
				else
					tee -a "${abl_dir}/allowlist"
				fi | wc -l
			)"

			fix_line_cnt list_part_line_count
			case ${list_part_line_count} in
				''|*[!0-9]*) reg_failure "Failed to process local ${list_type}."; return 1 ;;
				0) log_msg -warn "No lines remaining in local ${list_type} after sanitization." ;;
				*)
					log_msg "Sanitized local ${list_type} line count: $(int2human ${list_part_line_count})."
					list_line_count=$(( list_line_count + list_part_line_count ))
			esac
		elif [ -f "${local_list_path}" ]
		then
			log_msg -warn "Local ${list_type} file is empty."
		else
			log_msg -blue "No local ${list_type} identified."
		fi

		echo
		# List parts download
		if [ -n "${list_urls}" ]
		then
			reg_action -blue "Downloading new ${list_type} file part(s)." || return 1
		elif [ "${list_type}" = blocklist ]
		then
			log_msg -yellow "NOTE: No URLs specified for blocklist download. Skipping download."
		fi

		for list_url in ${list_urls}
		do
			list_id=$((list_id+1))
			retry=0
			while :
			do
				retry=$((retry + 1))
				download_and_process_list_part "${list_id}" "${list_type}" "${list_url}"
				case ${?} in
					0)
						list_line_count=$(( list_line_count + list_part_line_count ))
						if [ "${list_type}" = allowlist ]
						then
							cat "${abl_dir}/${list_type}.${list_id}" >> "${abl_dir}/allowlist" ||
								{ reg_failure "Failed to merge allowlist part."; return 1; }
						fi
						continue 2 ;;
					1) return 1 ;;
					2)
						[ "${list_part_failed_action}" = "STOP" ] && { reg_failure "list_part_failed_action is set to 'STOP', exiting."; return 1; }
						log_msg "Skipping file part and continuing."
						continue 2 ;;
					3) ;;
				esac

				if [ "${retry}" -ge "${max_download_retries}" ]
				then
					[ "${list_part_failed_action}" = "STOP" ] && { reg_failure "Giving up after three failed download attempts."; return 1; }
					log_msg "Skipping file part and continuing."
					continue 2
				fi

				reg_action -blue "Sleeping for 5 seconds after failed download attempt." || return 1
				sleep 5
				continue
			done

		done

		if [ "${list_line_count}" = 0 ] || { [ "${list_type}" = allowlist ] && [ ! -f "${abl_dir}/allowlist" ]; }
		then
			case ${list_type} in
				blocklist) return 1 ;;
				allowlist)
					log_msg "Not using any allowlist for blocklist processing."
					use_allowlist=0
					continue
			esac
		fi

		if [ "${list_type}" = allowlist ]
		then
			log_msg -green "Successfully generated allowlist with $(int2human ${list_line_count}) lines."
			log_msg "Will remove any (sub)domain matches present in the allowlist from the blocklist and append corresponding server entries to the blocklist."
			use_allowlist=1
		else
			preprocessed_blocklist_line_count="${list_line_count}"
		fi
	done
	:
}

generate_and_process_blocklist_file()
{
	echo
	reg_action -blue "Sorting and merging the blocklist lines into a single blocklist file." || return 1

	{
		[ "${use_allowlist}" = 1 ] && sed '/^$/d; s~.*~server=/&/#~' "${abl_dir}/allowlist"
		rm -f "${abl_dir}/allowlist"

		find "${abl_dir}" -name 'blocklist.*.gz' -exec gunzip -c {} \; -exec rm -f {} \;
	} | sort -u |
	{ head -c "${max_blocklist_file_size_KB}k"; cat 1>/dev/null; } |
	tee >(wc -l > "${abl_dir}/blocklist_file_line_count") |
	tee >(wc -c > "${abl_dir}/blocklist_file_size_B") |

	if  [ "${compress_blocklist}" = 1 ]
	then
		gzip > "${abl_dir}/blocklist.gz"
	else
		cat > "${abl_dir}/blocklist"
	fi

	good_line_count="$(cat "${abl_dir}/blocklist_file_line_count" 2>/dev/null)"
	: "${good_line_count:=0}"

	blocklist_file_size_B="$(cat "${abl_dir}/blocklist_file_size_B" 2>/dev/null)"
	blocklist_file_size_KB=$(( (blocklist_file_size_B + 0) / 1024 ))
	blocklist_file_size_human="$(bytes2human "${blocklist_file_size_B}")"

	if [ "${blocklist_file_size_KB}" -ge "${max_blocklist_file_size_KB}" ]
	then
		reg_failure "Blocklist file size reached the maximum value set in config ($(int2human "${max_blocklist_file_size_KB}") KB)."
		log_msg "Consider either increasing this value in the config or changing the blocklist URLs."
		return 1
	fi

	if [ "${good_line_count}" -lt "${min_good_line_count}" ]
	then
		reg_failure "Good line count: $(int2human "${good_line_count}") below the minimum value set in config ($(int2human "${min_good_line_count}"))."
		return 1
	fi

	log_msg "Processed blocklist uncompressed file size: ${blocklist_file_size_human}."

	:
}


# return codes:
# 0 - dnsmasq running
# 1 - dnsmasq not running or failed to detect dnsmasq directory
check_dnsmasq_instance()
{
	! pgrep -x /usr/sbin/dnsmasq &>/dev/null && { reg_failure "No running instance of dnsmasq detected."; return 1; }
	[ ! -d "${dnsmasq_tmp_d}" ] &&
		{ reg_failure "Directory '${dnsmasq_tmp_d}' does not exist. Failed to detect dnsmasq directory or dnsmasq is not running."; return 1; }
	:
}

# return values:
# 0 - dnsmasq is running, and all checks passed
# 1 - dnsmasq is not running
# 2 - dnsmasq is running, but one of the test domains failed to resolve
# 3 - dnsmasq is running, but one of the test domains resolved to 0.0.0.0
check_active_blocklist()
{
	echo
	reg_action -blue "Checking active blocklist." || return 1

	check_dnsmasq_instance || return 1

	for domain in google.com amazon.com microsoft.com
	do
		! ns_res="$(nslookup "${domain}" 127.0.0.1 2>/dev/null)" &&
			{ reg_failure "Lookup of '${domain}' failed with new blocklist."; return 2; }

		printf %s "${ns_res}" | grep -A1 ^Name | grep -q '^Address: *0\.0\.0\.0$' &&
			{ reg_failure "Lookup of '${domain}' resulted in 0.0.0.0 with new blocklist."; return 3; }
	done
	
	:
}

restart_dnsmasq()
{
	[ "$action" = "start" ] && echo
	reg_action -blue "Restarting dnsmasq." || return 1

	/etc/init.d/dnsmasq restart &> /dev/null || 
		{ reg_failure "Failed to restart dnsmasq."; return 1; }
	
	reg_action "Waiting for dnsmasq initialization." || return 1
	local dnsmasq_ok=
	for i in $(seq 1 60)
	do
		nslookup localhost 127.0.0.1 &> /dev/null && { dnsmasq_ok=1; break; }
		sleep 1;
	done

	[ -z "$dnsmasq_ok" ] && { reg_failure "dnsmasq initialization failed."; return 1; }

	log_msg -green "Restart of dnsmasq completed."
	:
}

# return codes:
# 0 - success
# 1 - failure
# 2 - blocklist file not found (nothing to export)
export_existing_blocklist()
{
	echo
	if [ -f "${dnsmasq_tmp_d}"/.blocklist.gz ]
	then
		log_msg -blue "Exporting and saving existing compressed blocklist."
		try_mv "${dnsmasq_tmp_d}"/.blocklist.gz "${abl_dir}/prev_blocklist.gz" || return 1
		return 0
	elif [ -f "${dnsmasq_tmp_d}"/blocklist ]
	then
		reg_action -blue "Exporting and saving existing uncompressed blocklist." || return 1
		gzip -f "${dnsmasq_tmp_d}"/blocklist ||
			{ reg_failure "Failed to compress '${dnsmasq_tmp_d}/blocklist'."; return 1; }
		try_mv "${dnsmasq_tmp_d}"/blocklist.gz "${abl_dir}/prev_blocklist.gz" || return 1
		return 0
	else
		log_msg "No existing compressed or uncompressed blocklist identified."
		return 2
	fi
}

restore_saved_blocklist()
{
	if [ -f "${abl_dir}/prev_blocklist.gz" ]
	then
		reg_action -blue "Restoring saved blocklist file." || return 1
		try_mv "${abl_dir}/prev_blocklist.gz" "${abl_dir}/blocklist.gz" || return 1
		if [ "${compress_blocklist}" != 1 ]
		then
			gunzip -f "${abl_dir}/blocklist.gz" ||
				{ reg_failure "Failed to extract '${abl_dir}/blocklist.gz'."; return 1; }

		fi
		import_blocklist_file ||
			{ reg_failure "Failed to import the blocklist file."; return 1; }
		return 0
	else
		reg_failure "No previous blocklist file found."
		return 1
	fi
}

import_blocklist_file()
{
	local src_file="${abl_dir}/blocklist" dest_file="${dnsmasq_tmp_d}/blocklist"
	[ "${compress_blocklist}" = 1 ] && { src_file="${src_file}.gz" dest_file="${dnsmasq_tmp_d}/.blocklist.gz"; }
	[ -f "${src_file}" ] || return 1
	clean_dnsmasq_dir
	try_mv "${src_file}" "${dest_file}" || return 1
	imported_blocklist_file_size_human=$(get_file_size_human "${dest_file}")

	if [ "${compress_blocklist}" = 1 ]
	then
		printf "conf-script=\"busybox sh ${dnsmasq_tmp_d}/.extract_blocklist\"\n" > "${dnsmasq_tmp_d}"/conf-script &&
		printf "busybox gunzip -c ${dnsmasq_tmp_d}/.blocklist.gz\nexit 0\n" > "${dnsmasq_tmp_d}"/.extract_blocklist ||
			{ reg_failure "Failed to create conf-script for dnsmasq."; return 1; }
	fi

	:
}

# return values:
# 0 - up-to-date
# 1 - not up-to-date
# 2 - update check failed
check_for_updates()
{
	echo
	rm -f "${abl_dir}/uclient-fetch_err"
	sha256sum_adblock_lean_local=$(sha256sum /etc/init.d/adblock-lean | sed 's/[ \t]*-.*//')
	sha256sum_adblock_lean_remote=$(uclient-fetch https://raw.githubusercontent.com/lynxthecat/adblock-lean/master/adblock-lean -O - \
		2> "${abl_dir}/uclient-fetch_err" | sha256sum | sed 's/[ \t]*-.*//')

	local bad_dl='' update_check_result=''

	# safeguard against receiving empty string or empty string+newline
	case "${sha256sum_adblock_lean_remote}" in *9805daca546b|*991b7852b855) bad_dl=1; esac

	if [ -z "${bad_dl}" ] && grep -q "Download completed" "${abl_dir}/uclient-fetch_err"
	then
		if [ "${sha256sum_adblock_lean_local}" = "${sha256sum_adblock_lean_remote}" ]
		then
			log_msg "The locally installed adblock-lean is the latest version."
			update_check_result=0
		else
			log_msg -yellow "The locally installed adblock-lean seems to be outdated."
			log_msg "Consider running: 'service adblock-lean update' to update it to the latest version."
			update_check_result=1
		fi
	else
		reg_failure "Unable to download latest version of adblock-lean to check for any updates."
		update_check_result=2
	fi
	rm -f "${abl_dir}/uclient-fetch_err"

	return ${update_check_result}
}

# updates the pid file with a new action
# 1 - new action
update_pid_action() {
	check_lock
	case ${?} in
		3) ;;
		1) return 1 ;;
		2) reg_failure "update_pid_action(): pid file '${pid_file}' has unexpected pid '${_pid}'."; return 1 ;;
		0) reg_failure "update_pid_action(): pid file '${pid_file}' not found."; return 1
	esac
	mk_lock -f "${1}"
	return ${?}
}

# args:
# 1 - (optional) -f to skip check for existing lock
# 1/2 - action to write to the pid file
#
# return codes:
# 0 - success
# 1 - error
# 254 - lock file already exists
mk_lock()
{
	if [ "${1}" != '-f' ]
	then
		check_lock
		case ${?} in
			1) return 1 ;;
			2)
				report_pid_action
				log_msg "Refusing to open another instance."
				return 254
		esac
	else
		shift
	fi

	[ -z "${1%.}" ] && { log_msg "mk_lock(): pid action is unspecified."; return 1; }
	if [ -n "${pid_file}" ]
	then
		if [ ! -d "${tmp_abl_dir}" ]
		then
			mkdir -p "${tmp_abl_dir}" || { reg_failure "Failed to create directory '${tmp_abl_dir}'."; return 1; }
		fi
		printf '%s\n' "${$} ${1%.}" > "${pid_file}" || { reg_failure "Failed to write to pid file '${pid_file}'."; return 1; }
	else
		reg_failure "\${pid_file} variable is unset."
		return 1
	fi
	:
}

rm_lock()
{
	if [ -f "${pid_file}" ]
	then
		rm -f "${pid_file}" || { reg_failure "Failed to delete the pid file '${pid_file}'."; return 1; }
	fi
	:
}

# return codes:
# 0 - no lock
# 1 - error
# 2 - lock file exists and belongs to another PID
# 3 - lock file belongs to current PID
check_lock()
{
	unset _pid pid_action
	[ -z "${pid_file}" ] && { reg_failure "\${pid_file} variable is unset."; return 1; }
	[ ! -f "${pid_file}" ] && return 0
	if read -r _pid pid_action < "${pid_file}"
	then
		case "${_pid}" in
			${$}) return 3 ;;
			*[!0-9]*) reg_failure "pid file '${pid_file}' contains unexpected string."; return 1 ;;
			*) kill -0 "${_pid}" 2>/dev/null && return 2
		esac
	else
		reg_failure "Failed to read the pid file '${pid_file}'."
		return 1
	fi

	log_msg -warn "Detected stale pid file '${pid_file}'. Removing."
	rm_lock || return 1
	:
}

# kills any running adblock-lean instances
kill_abl_pids()
{
	local _killed _p _pid IFS=$'\n' k_attempt=0
	while :; do
		k_attempt=$((k_attempt+1))
		_killed=
		for _p in $(pgrep -fa '(/etc/rc.common /etc/init.d/adblock-lean|luci.adblock-lean)')
		do
			_pid="${_p%% *}"
			case ${_pid} in "${$}"|*[!0-9]*) continue; esac
			kill "${_pid}" 2>/dev/null
			_killed=1
		done
		[ -z "${_killed}" ] || [ ${k_attempt} -gt 10 ] && break
		sleep 1
	done
	:
}

# (optional) -nolog
# (optional) -[color]
# other args - action
reg_action()
{
	local msg='' nolog='' color=''
	for _arg in "$@"; do
		case "${_arg}" in
			-nolog) nolog=1 ;;
			-blue|-red|-green|-purple|-yellow) color="${_arg}" ;;
			*) msg="${msg}${_arg} "
		esac
	done

	[ -z "${nolog}" ] && log_msg "${color}" "${msg% }"
	if [ -n "${lock_req}" ]
	then
		update_pid_action "${msg% }" || return 1
	fi
	:
}

report_pid_action()
{
	local reported_pid="unknown PID"
	[ -n "${_pid}" ] && reported_pid="PID ${_pid}"
	: "${pid_action:="unknown action"}"
	print_msg "adblock-lean (${reported_pid}) is performing action '${pid_action}'."
	luci_pid_action=${pid_action}
	:
}

init_command()
{
	action="${1}"
	pid_file="${tmp_abl_dir}/adblock-lean.pid"
	unset lock_req kill_req cleanup_req failure_msg luci_errors

	# detect if sourced from external RPC script for luci, depends on abl_luci_exit() being defined
	luci_sourced=
	command -v "abl_luci_exit" 1>/dev/null && luci_sourced=1

	trap 'cleanup_and_exit 1' INT TERM
	trap 'cleanup_and_exit ${?}' EXIT

	case ${action} in
		help|status|gen_stats|enabled|enable|disable|'') ;;
		gen_config|pause) lock_req=1 ;;
		boot|start|update|resume) cleanup_req=1 lock_req=1 ;;
		stop)
			reg_action -purple "Stopping adblock-lean." || exit 1
			cleanup_req=1 kill_req=1 lock_req=1 ;;
		reload|restart)
			reg_action -purple "Restarting adblock-lean." || exit 1
			cleanup_req=1 kill_req=1 lock_req=1 ;;
		*)
			reg_failure "Invalid action '${action}'."
			exit 1
	esac

	if [ -n "${kill_req}" ]
	then
		kill_abl_pids
		check_lock
		case ${?} in
			1) exit 1 ;;
			2)
				reg_failure "Failed to kill running adblock-lean processes."
				exit 1
		esac
	fi

	case ${action} in
		help|gen_config|enable|disable|enabled|'') ;;
		*)
			dnsmasq_tmp_d="$(uci get dhcp.@dnsmasq[0].confdir 2>/dev/null)"
			: "${dnsmasq_tmp_d:=/tmp/dnsmasq.d}"
			check_dnsmasq_instance || exit 1
	esac

	if [ -n "${lock_req}" ]
	then
		mk_lock "${action}" || { unset lock_req cleanup_req; exit ${?}; }
	fi

	case ${action} in
		help|gen_config|enable|disable|enabled|stop|'') ;;
		status) mkdir -p "${abl_dir}" ;;
		*)
			mkdir -p "${abl_dir}" "${dnsmasq_tmp_d}"
			load_config || { reg_failure "Failed to load config."; exit 1; }
			if [ -n "${custom_script}" ]
			then
				custom_scr_sourced=
				[ -f "${custom_script}" ] && . "${custom_script}" && custom_scr_sourced=1
				[ -z "${custom_scr_sourced}" ] && reg_failure "Custom script '${custom_script}' doesn't exist or it returned error."
			fi
	esac

	:
}

### MAIN COMMAND FUNCTIONS

# 1 - (optional) '-noexit' to return to the calling function
gen_stats()
{
	echo
	reg_action -blue "Generating dnsmasq stats." || exit 1
	kill -USR1 $(pgrep dnsmasq)
	print_msg "dnsmasq stats available for reading using 'logread'."
	[ "${1}" != '-noexit' ] && exit 0
}

gen_config()
{
	init_command gen_config || exit 1
	local missing_keys='' missing_entries='' unexp_keys='' unexp_entries='' legacy_keys='' legacy_entries=''
	reg_action -purple "Generating new default config for adblock-lean." || exit 1
	if [ "${msgs_dest}" = "/dev/tty" ] && [ -f "${config_file}" ]
	then
		print_msg "This will overwrite existing config with default one. Proceed?"
		pick_opt "y|n" || exit 1
		[ "${REPLY}" = n ] && exit 1
	fi
	mkdir -p "${PREFIX}"
	write_config "$(print_def_config)" || exit 1
	parse_config "${config_file}" || exit 1
	check_blocklist_compression_support
	:
}

boot()
{
	init_command boot || exit 1
	reg_action -purple "Sleeping for ${boot_start_delay_s} seconds." || exit 1
	sleep "${boot_start_delay_s}"
	start "$@"
}

start() 
{
	init_command start || exit 1
	log_msg -purple "Started adblock-lean."

	if type gawk &> /dev/null
	then
		log_msg "gawk detected so using gawk for fast (sub)domain match removal."
		awk_cmd="gawk"
	else
		log_msg "gawk not detected so using awk for the (sub)domain match removal."
		log_msg "Consider installing the gawk package 'opkg install gawk' for faster (sub)domain match removal."
		awk_cmd="awk"
	fi

	if sort --version 2>/dev/null | grep -qe coreutils
	then
		log_msg "coreutils-sort detected so sort will be fast."
	else
		log_msg "coreutils-sort not detected so sort will be a little slower."
		log_msg "Consider installing the coreutils-sort package (opkg install coreutils-sort) for faster sort."
	fi

	if [ "${compress_blocklist}" = 1 ]
	then
		check_blocklist_compression_support || exit 1
	fi

	if [ "${RANDOM_DELAY}" = "1" ]
	then
		random_delay_mins=$(($(hexdump -n 1 -e '"%u"' </dev/urandom)%60))
		reg_action -purple "Delaying adblock-lean by: ${random_delay_mins} minutes (thundering herd prevention)." || exit 1
		sleep "${random_delay_mins}m"
	fi

	try_export_existing_blocklist
	[ ${?} = 1 ] && exit 1

	if [ "${initial_dnsmasq_restart}" = 1 ]
	then
		restart_dnsmasq || exit 1
	fi

	initial_uptime_ms=$(get_uptime_ms)

	if ! gen_list_parts
	then
		reg_failure "Failed to generate preprocessed blocklist file with at least one line."
		restore_saved_blocklist
		exit 1
	fi

	log_msg -green "Successfully generated preprocessed blocklist file based on $(int2human ${preprocessed_blocklist_line_count}) lines."

	if ! generate_and_process_blocklist_file
	then
		reg_failure "New blocklist file check failed."
		restore_saved_blocklist
		exit 1
	fi

	log_msg -green "New blocklist file check passed."

	if ! import_blocklist_file
	then
		reg_failure "Failed to import new blocklist file."
		restore_saved_blocklist
		exit 1
	fi

	compressed=
	[ "${compress_blocklist}" = 1 ] && compressed=" compressed"
	log_msg "Successfully imported new${compressed} blocklist file for use by dnsmasq with size: ${imported_blocklist_file_size_human}."

	elapsed_time_str=$(get_elapsed_time_str)
	echo
	log_msg "Processing time for blocklist generation and import: ${elapsed_time_str}."

	restart_dnsmasq || exit 1

	if ! check_active_blocklist
	then
		reg_failure "Active blocklist check failed with new blocklist file."

		if ! restore_saved_blocklist
		then
			reg_failure "Failed to restore saved blocklist."
			stop 1
		fi

		if ! restart_dnsmasq
		then
			log_msg "Stopping adblock-lean."
			stop 1
		fi

		if ! check_active_blocklist
		then
			reg_failure "Active blocklist check failed with previous blocklist file."
			stop 1
		fi

		log_msg -green "Previous blocklist restored and dnsmasq check passed."
		exit 1
	fi

	log_msg -green "Active blocklist check passed with new blocklist file."
	log_success "New blocklist installed with good line count: $(int2human "${good_line_count}")."
	rm -f "${abl_dir}/prev_blocklist.gz"

	check_for_updates
	exit 0
}

# 1 - (optional) exit code
# 1/2 - (optional) '-noexit' to return to the calling function
stop()
{
	local stop_rc=0 noexit=
	for _arg in "$@"; do
		case "${_arg}" in
			"-noexit") noexit=1 ;;
			*[!0-9]*|'') ;;
			*) stop_rc="${_arg}"
		esac
	done
	msg="${msg% }"

	init_command stop || exit 1
	reg_action "Removing any adblock-lean blocklist files in ${dnsmasq_tmp_d}/ and restarting dnsmasq." || exit 1
	clean_dnsmasq_dir
	/etc/init.d/dnsmasq restart &> /dev/null
	log_msg -purple "Stopped adblock-lean."
	[ -n "$noexit" ] && return "${stop_rc}"
	exit "${stop_rc}"
}

restart()
{
	init_command restart || exit 1
	stop -noexit || exit 1
	start
}

reload()
{
	restart
}

# return values:
# 0 - adblock-lean blocklist is loaded
# 1 - error
# 2 - adblock-lean is performing an action
# 3 - adblock-lean is paused
# 4 - adblock-lean is stopped
status()
{
	init_command status || exit 1
	check_lock
	case ${?} in
		1) exit 1 ;;
		2)
			report_pid_action
			exit 2
	esac

	get_abl_run_state
	case ${?} in
		0) ;;
		3) log_msg -purple "adblock-lean is currently paused."; exit 3 ;;
		4) log_msg -purple "adblock-lean is stopped."; exit 4;
	esac
	check_active_blocklist
	dnsmasq_status=${?}
	luci_dnsmasq_status=${dnsmasq_status}
	if [ ${dnsmasq_status} = 0 ]
	then
		if [ -f "${dnsmasq_tmp_d}"/.blocklist.gz ]
		then
			good_line_count=$(gunzip -c "${dnsmasq_tmp_d}"/.blocklist.gz | wc -l)
		elif [ -f "${dnsmasq_tmp_d}"/blocklist ]
		then
			good_line_count=$(wc -l "${dnsmasq_tmp_d}"/blocklist)
		fi
		: "${good_line_count:=0}"
		luci_good_line_count=${good_line_count}
		log_msg "The dnsmasq check passed and the presently installed blocklist has good line count: $(int2human ${good_line_count})."
		log_msg -green "adblock-lean appears to be active."
		gen_stats -noexit
	else
		reg_failure "The dnsmasq check failed with existing blocklist file."
		log_msg "Consider a full reset by running: 'service adblock stop'."
	fi
	check_for_updates
	luci_update_status=${?}

	exit 0
}

pause()
{
	init_command pause || exit 1
	get_abl_run_state
	case ${?} in
		0) ;;
		3) log_msg -err "adblock-lean is already paused."; exit 1 ;;
		4) log_msg -err "adblock-lean is currently stopped."; exit 1;
	esac
	reg_action -purple "Pausing adblock-lean." || exit 1
	try_export_existing_blocklist || exit 1
	restart_dnsmasq || exit 1
	log_msg -purple "adblock-lean is now paused."
	exit 0
}

resume()
{
	init_command resume || exit 1
	get_abl_run_state
	case ${?} in
		0) log_msg -err "adblock-lean is already running."; exit 1 ;;
		3) ;;
		4) log_msg -err "adblock-lean is currently stopped, not paused. Can not resume."; exit 1;
	esac

	reg_action -purple "Resuming adblock-lean." || exit 1
	restore_saved_blocklist || 
		{ reg_failure "Failed to restore saved blocklist. Stopping adblock-lean."; stop 1; }
	restart_dnsmasq || exit 1
	log_msg -purple "adblock-lean is now resumed."
	exit 0
}

update()
{
	init_command update || exit 1
	reg_action -purple "Obtaining latest version of adblock-lean." || exit 1
	uclient-fetch https://raw.githubusercontent.com/lynxthecat/adblock-lean/master/adblock-lean \
		-O "${abl_dir}/adblock-lean.latest" 1> /dev/null 2> "${abl_dir}/uclient-fetch_err"
	if grep -q "Download completed" "${abl_dir}/uclient-fetch_err"
	then
		try_mv "${abl_dir}/adblock-lean.latest" /etc/init.d/adblock-lean || exit 1
		chmod +x /etc/init.d/adblock-lean
		/etc/init.d/adblock-lean enable
		log_msg "adblock-lean has been updated to the latest version."
	else
		reg_failure "Unable to download latest version of adblock-lean."
	fi
	rm -f "${abl_dir}/adblock-lean.latest" "${abl_dir}/uclient-fetch_err"
	exit 0
}

set_colors
sed_san_expr='s/#.*$//; s/^[ \t]*//; s/[ \t]*$//; /^$/d'
sed_conf_san_exp='/^[ \t]*#.*$/d; s/^[ \t]*//; s/[ \t]*$//; /^$/d'
:
