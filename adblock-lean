#!/bin/sh /etc/rc.common
# shellcheck disable=SC3043,SC1091,SC3001,SC2018,SC2019,SC3020,SC3003,SC2181,SC2254,SC1090,SC3045

# adblock-lean - super simple and lightweight adblocking for OpenWrt

# Project homepage: https://github.com/lynxthecat/adblock-lean

# Authors: @Lynx and @Wizballs (OpenWrt forum)
# Contributors: @antonk; @dave14305 (OpenWrt forum)

# global exit codes:
# 0 - Success
# 1 - Error
# 254 - Failed to acquire lock

# special variables for luci have the prefix 'luci_'

# expects that the RPC script for luci UI is named specifically 'luci.adblock-lean'

# get return value of built-in actions
action_rv="${?}"

LC_ALL=C
IFS='	 
'
nl='
'
default_IFS="${IFS}"

if [ -t 0 ]
then
	msgs_dest=/dev/tty
else
	msgs_dest=/dev/null
fi

abl_service_path=/etc/init.d/adblock-lean
config_dir=/etc/adblock-lean
config_file=${config_dir}/config
root_config_file=/root/adblock-lean/config # @config_migration_logic
abl_dir=/var/run/adblock-lean
abl_pid_dir=/tmp/adblock-lean
update_log_file=/var/log/abl_update.log
session_log_file=/var/log/abl_session.log
hagezi_dl_url="https://raw.githubusercontent.com/hagezi/dns-blocklists/main/wildcard"
abl_cron_cmd="/etc/init.d/adblock-lean start"
cron_service_path="/etc/init.d/cron"

export PATH=/usr/sbin:/usr/bin:/sbin:/bin
export HOME=/root

START=99
STOP=4

EXTRA_COMMANDS="setup status pause resume gen_stats gen_config upd_cron_job print_log update uninstall"
EXTRA_HELP="
adblock-lean custom commands:
	setup           run automated setup for adblock-lean
	status          check dnsmasq and entries count of existing blocklist
	pause           pause adblock-lean
	resume          resume adblock-lean
	gen_stats       generate dnsmasq stats for system log
	gen_config      generate default config based on one of the pre-defined presets
	upd_cron_job    create cron job for adblock-lean with schedule set in the config option 'cron_schedule'.
	                if config option set to 'disable', remove existing cron job if any
	print_log       print most recent session log
	update          update adblock-lean to the latest version
	uninstall       uninstall adblock-lean, remove all adblock-lean-related files and settings"


### UTILITY FUNCTIONS

# sets variables for colors
set_colors()
{
	set -- $(printf '\033[0;31m \033[0;32m \033[1;34m \033[1;33m \033[0;35m \033[0m')
	red="${1}" green="${2}" blue="${3}" yellow="${4}" purple="${5}" n_c="${6}"
}

get_file_size_human()
{
	bytes2human "$(du -b "$1" | awk '{print $1}')"
}

# converts unsigned integer to [xB|xKiB|xMiB|xGiB|xTiB]
# if result is not an integer, outputs up to 2 digits after decimal point
# 1 - int
bytes2human()
{
	local i=${1:-0} s=0 d=0 m=1024 fp='' S=''
	case "$i" in *[!0-9]*) reg_failure "bytes2human: Invalid unsigned integer '$i'."; return 1; esac
	for S in B KiB MiB GiB TiB
	do
		[ $((i > m && s < 4)) = 0 ] && break
		d=$i i=$((i/m)) s=$((s+1))
	done
	d=$((d % m * 100 / m))
	case $d in
		0) printf "%s %s\n" "$i" "$S"; return ;;
		[1-9]) fp="02" ;;
		*0) d=${d%0}; fp="01"
	esac
	printf "%s.%${fp}d %s\n" "$i" "$d" "$S"
}

int2human()
{
	case "$1" in *[!0-9]*) reg_failure "int2human: Invalid unsigned integer '$1'."; return 1; esac
	local in_num="$1" out_num=''

	# strip leading zeroes
	while :
	do
		case "$in_num" in
			0?*) in_num="${in_num#0}" ;;
			*) break
		esac
	done

	while :
	do
		case "$in_num" in 
			????*)
				out_num=",${in_num#"${in_num%???}"}${out_num}"
				in_num="${in_num%???}" ;;
			*) break
		esac
	done
	out_num="${in_num}${out_num}"

	echo "${out_num#,}"
}

get_uptime_ms()
{
	read -r uptime_ms _ < /proc/uptime
	printf "${uptime_ms%.*}${uptime_ms#*.}0"
}

get_elapsed_time_str()
{
	# To use, first set initial uptime: initial_uptime_ms=$(get_uptime_ms)
	# Then call this function to get elapsed time string at desired intervals, e.g.:
	# printf "Elapsed time: $(get_elapsed_time_str)\n"

	elapsed_time_s=$(( ($(get_uptime_ms)-${initial_uptime_ms:-$(get_uptime_ms)})/1000 ))
	printf '%dm:%ds' $((elapsed_time_s/60)) $((elapsed_time_s%60))
}

# prints each argument into a separate line
print_msg()
{
	local m
	for m in "${@}"
	do
		printf '%s\n' "${m}" > "$msgs_dest"
	done
}

# logs each message argument separately and prints to a separate line
# optional arguments: '-err', '-warn', '-[color]'
log_msg()
{
	local m msgs='' msgs_prefix='' _arg err_l=info color=

	for _arg in "$@"
	do
		case "${_arg}" in
			"-err") err_l=err color="${red}" msgs_prefix="Error: " ;;
			"-warn") err_l=warn color="${yellow}" msgs_prefix="Warning: " ;;
			-blue|-red|-green|-purple|-yellow) eval "color=\"\${${_arg#-}}\"" ;;
			'') msgs="${msgs}dummy${nl}" ;;
			*) msgs="${msgs}${msgs_prefix}${_arg}${nl}"; [ -n "${msgs_prefix}" ] && msgs_prefix=
		esac
	done
	msgs="${msgs%${nl}}"
	local IFS="${nl}"

	for m in ${msgs}
	do
		case "${m}" in
			dummy) echo ;;
			*)
				print_msg "${color}${m}${n_c}"
				logger -t adblock-lean -p user."${err_l}" "${m}"
				write_log_file "${m}" "${err_l}"
		esac
	done
}

# 1 - msg
# 2 - err level
write_log_file()
{
	[ -n "${log_file}" ] && { printf '['; date +'%b %d %Y, %H:%M:%S' | tr -d '\n'; printf '] %s\n' "${2:-info}: ${1}"; } >> "${log_file}"
}

try_mv()
{
	[ -z "${1}" ] || [ -z "${2}" ] && { reg_failure "try_mv(): bad arguments."; return 1; }
	mv -f "${1}" "${2}" || { reg_failure "Failed to move '${1}' to '${2}'."; return 1; }
	:
}

# 0 - (optional) '-p'
# 1 - path
try_mkdir()
{
	local p=
	[ "${1}" = '-p' ] && { p='-p'; shift; }
	[ -d "${1}" ] && return 0
	mkdir ${p} "${1}" || { reg_failure "Failed to create directory '${1}'."; return 1; }
	:
}

try_gzip()
{
	gzip -f "${1}" || { rm -f "${1}.gz"; reg_failure "Failed to compress '${1}'."; return 1; }
}

try_gunzip()
{
	gunzip -f "${1}" || { rm -f "${1%.gz}"; reg_failure "Failed to extract '${1}'."; return 1; }
}

# asks the user to pick an option
# 1 - input in the format 'a|b|c'
# output via $REPLY
pick_opt()
{
	update_pid_action "Waiting for user input in console" || return 1
	while :
	do
		printf %s "$1: " 1>${msgs_dest}
		read -r REPLY
		case "$REPLY" in *[!A-Za-z0-9]*) printf '\n%s\n\n' "Please enter $1" 1>${msgs_dest}; continue; esac
		eval "case \"$REPLY\" in 
				$1) return 0 ;;
				*) printf '\n%s\n\n' \"Please enter $1\" 1>${msgs_dest}
			esac"
	done
}


### HELPER FUNCTIONS

# (optional) -d to print with allowed value types (otherwise print without)
# (optional) -p to print with values from preset
print_def_config()
{
	# follow each default option with '@' and a pre-defined type: string, integer (implies unsigned integer)
	# or custom optional values, examples: opt1, opt1|opt2, ''|opt1|opt2

	mk_preset_arrays
	: "${preset:=small}"
	case "${preset}" in mini|small|medium|large) ;; *) reg_failure "print_def_config: \$preset var has invalid value."; exit 1; esac
	gen_preset "${preset}" -n

	cat <<-EOT | if [ "${1}" = '-d' ]; then cat; else sed 's/[ \t]*@.*//'; fi

	# adblock-lean configuration options
	# config_format=v5
	#
	# values must be enclosed in double-quotes
	# custom comments are not preserved after automatic config update

	# Whitelist mode: only domains (and their subdomains) included in the allowlist(s) are allowed, all other domains are blocked
	# In this mode, if blocklists are used in addition to allowlists, subdomains included in the blocklists will be blocked,
	# including subdomains of allowed domains
	whitelist_mode="0" @ 0|1

	# One or more *raw domain* format blocklist/ipv4 blocklist/allowlist urls separated by spaces
	blocklist_urls="${blocklist_urls}" @ string
	blocklist_ipv4_urls="" @ string
	allowlist_urls="" @ string

	# One or more *dnsmasq format* domain blocklist/ipv4 blocklist/allowlist urls separated by spaces
	dnsmasq_blocklist_urls="" @ string
	dnsmasq_blocklist_ipv4_urls="" @ string
	dnsmasq_allowlist_urls="" @ string

	# Path to optional local *raw domain* allowlist/blocklist files in the form:
	# site1.com
	# site2.com
	local_allowlist_path="${config_dir}/allowlist" @ string
	local_blocklist_path="${config_dir}/blocklist" @ string

	# Test domains are automatically querried after loading the blocklist into dnsmasq,
	# in order to verify that the blocklist didn't break DNS resolution
	# If query for any of the test domains fails, previous blocklist is restored from backup
	# If backup doesn't exist, the blocklist is removed and adblock-lean is stopped
	# Leaving this empty will disable verification
	test_domains="google.com microsoft.com amazon.com" @ string

	# List part failed action:
	# This option applies to blocklist/allowlist parts which failed to download or couldn't pass validation checks
	# SKIP - skip failed blocklist file part and continue blocklist generation
	# STOP - stop blocklist generation (and fall back to previous blocklist if available)
	list_part_failed_action="SKIP" @ SKIP|STOP

	# Maximum number of download retries
	max_download_retries="3" @ integer

	# Minimum number of good lines in final postprocessed blocklist
	min_good_line_count="${min_good_line_count}" @ integer

	# Mininum number of lines of any individual downloaded part
	min_blocklist_part_line_count="1" @ integer
	min_blocklist_ipv4_part_line_count="1" @ integer
	min_allowlist_part_line_count="1" @ integer

	# Maximum size of any individual downloaded blocklist part
	max_file_part_size_KB="${max_file_part_size_KB}" @ integer

	# Maximum total size of combined, processed blocklist
	max_blocklist_file_size_KB="${max_blocklist_file_size_KB}" @ integer

	# Whether to perform sorting and deduplication of entries (usually doesn't cause much slowdown, uses a bit more memory) - enable (1) or disable (0)
	deduplication="1" @ 0|1

	# compress final blocklist, intermediate blocklist parts and the backup blocklist to save memory - enable (1) or disable (0)
	use_compression="1" @ 0|1

	# restart dnsmasq if previous blocklist was extracted and before generation of
	# new blocklist thereby to free up memory during generaiton of new blocklist - enable (1) or disable (0)
	initial_dnsmasq_restart="0" @ 0|1

	# Start delay in seconds when service is started from system boot
	boot_start_delay_s="120" @ integer

	# If a path to custom script is specified and that script defines functions 'report_success()' and 'report_failure()'',
	# one of these functions will be executed when adblock-lean completes the execution of some commands,
	# with the success or failure message passed in first argument
	# report_success() is only executed upon completion of the 'start' command
	# Recommended path is '/usr/libexec/abl_custom-script.sh' which the luci app has permission to access
	custom_script="" @ string

	# Crontab schedule expression for periodic list updates
	cron_schedule="${cron_schedule:-"0 5 * * *"}" @ string

	EOT
}

# 1 - mini|small|medium|large
# 2 - (optional) '-d' to print the description
# 2 - (optional) '-n' to print nothing (only assign values to vars)
gen_preset()
{
	local val field mem cnt i=1
	eval "mem=\"\${${1}_mem}\" cnt=\"\${${1}_cnt}\""
	[ "${2}" = '-d' ] && print_msg "" "${purple}${1}${n_c}: recommended for devices with ${mem} MB of memory."
	[ "${2}" != '-n' ] && print_msg "${blue}Elements count:${n_c} ~${cnt}k"
	for field in blocklist_urls max_file_part_size_KB max_blocklist_file_size_KB min_good_line_count
	do
		eval "val=\"\${${1}_${i}}\""
		eval "${field}=\"${val}\""
		[ "${2}" != '-n' ] && print_msg "${blue}${field}${n_c}=\"${val}\""
		i=$((i+1))
	done
}

mk_preset_arrays()
{
	# quasi-arrays for presets: 1 - url, 2 - max part size, 3 - max blocklist size, 4 - min line count,
	# cnt - elements count/1000, mem - memory in MB
	mini_1="${hagezi_dl_url}/pro.mini-onlydomains.txt" \
		mini_2=4000 mini_3=4000 mini_4=40000 mini_cnt=85 mini_mem=64
	small_1="${hagezi_dl_url}/pro-onlydomains.txt ${hagezi_dl_url}/tif.mini-onlydomains.txt" \
		small_2=7000 small_3=10000 small_4=100000 small_cnt=250 small_mem=128
	medium_1="${hagezi_dl_url}/pro-onlydomains.txt ${hagezi_dl_url}/tif.medium-onlydomains.txt" \
		medium_2=10000 medium_3=20000 medium_4=200000 medium_cnt=350 medium_mem=256
	large_1="${hagezi_dl_url}/pro-onlydomains.txt ${hagezi_dl_url}/tif-onlydomains.txt" \
		large_2=30000 large_3=50000 large_4=200000 large_cnt=700 large_mem=512
}

# sets ${preset} to recommended preset, depending on system memory capacity
mk_def_preset()
{
	unset preset totalmem
	local mem cnt
	local IFS="${default_IFS}"
	read -r _ totalmem _ < /proc/meminfo
	case "${totalmem}" in
		''|*[!0-9]*) reg_failure "\$totalmem has invalid value '${totalmem}'. Failed to determine system memory capacity."; return 1 ;;
		*)
			for preset in large medium small mini
			do
				eval "mem=\"\${${preset}_mem}\""
				# multiplying by 800 rather than 1024 to account for some memory not available to the kernel
				[ "${totalmem}" -ge $((mem * 800)) ] && break
			done
	esac
	:
}

# get config format from config file contents
# input via STDIN or ${1}
get_config_format()
{
	local conf_form_sed_expr='/^[ \t]*#[ \t]*config_format=v/{s/.*=v//;p;q;}'
	if [ -n "${1}" ]
	then
		sed -n "${conf_form_sed_expr}" "${1}"
	else
		sed -n "${conf_form_sed_expr}"
	fi
}

# @url_conversion_logic
# URL conversion logic can be removed in a few months from now (Sep 2024) - most bits to remove marked as @url_conversion_logic
# convert known dnsmasq-formatted URLs to wildcard domain URLs
# assign converted URLs to ${conv_*} or ${conv_dnsmasq_*}
# assign old urls to ${orig_*}
# assign URLs not requiring conversion to ${correct_*}
mk_conv_urls()
{
	# 1 - old var name
	# 2 - replacement pattern
	# 3 - replacement string
	replace_str()
	{
		# this function simplifies the code inside eval
		do_replace() { new_str_l="${new_str_l%%${pattern_l}*}${repl_str_l}${new_str_l#*${pattern_l}}"; }

		local var_name_l="${1}" pattern_l="${2}" repl_str_l="${3}" new_str_l=
		eval "new_str_l=\"\${${var_name_l}}\"
			case \"\${new_str_l}\" in *${pattern_l}*) do_replace; esac
			${var_name_l}=\"\${new_str_l}\""
	}

	# 1 - url
	# 2 - entry name
	add_orig_url() { eval "orig_${2}_urls=\"\${orig_${2}_urls}${1} \""; }

	# 1 - url
	# 2 - entry name
	add_corr_url() { eval "correct_${2}_urls=\"\${correct_${2}_urls}${1} \""; }

	# 1 - old url var name
	# 2 - replacement pattern
	# 3 - replacement string
	# 4 - entry name
	add_conv_url()
	{
		local var_name="${1}" pattern="${2}" repl_str="${3}" entry_name="${4}" orig_str new_str
		eval "orig_str=\"\${${var_name}}\""
		new_str="${orig_str}"
		replace_str new_str "${pattern}" "${repl_str}"
		eval "conv_${entry_name}_urls=\"\${conv_${entry_name}_urls}${new_str} \""
		url_conv_req=1
	}

	local entry urls dnsmasq_urls e IFS="${default_IFS}"

	for entry in blocklist blocklist_ipv4 allowlist
	do
		unset urls dnsmasq_urls

		eval "[ -n \"\${${entry}_urls+x}\" ] && urls=\"\${${entry}_urls}\"" &&
		curr_url_entries="${curr_url_entries}${blue}${entry}_urls${n_c}=\"${urls}\""$'\n'

		eval "[ -n \"\${dnsmasq_${entry}_urls+x}\" ] && dnsmasq_urls=\"\${dnsmasq_${entry}_urls}\"" &&
		curr_dnsmasq_url_entries="${curr_dnsmasq_url_entries}${blue}dnsmasq_${entry}_urls${n_c}=\"${dnsmasq_urls}\""$'\n'

		[ -z "${urls}" ] && continue
		for url in ${urls}
		do
			e=
			local hagezi_dl_url="raw.githubusercontent.com/hagezi/dns-blocklists/main"
			case "${url}" in
				*"${hagezi_dl_url}/wildcard/"*) add_corr_url "${url}" "${entry}"; e=1 ;;
				*"${hagezi_dl_url}/dnsmasq/"*)
					case "${url%.txt}" in
						*tif-ips)
							add_orig_url "${url}" blocklist_ipv4
							add_conv_url url "/dnsmasq/tif-ips.txt" "/ips/tif.txt" blocklist_ipv4
							e=1 ;;
						*/pro*|*/tif|*/tif.*|*anti.piracy|*doh|*doh-vpn-proxy-bypass|*dyndns|*fake|*gambling|*hoster|*light|*multi|*native*|\
							*nosafesearch|*popupads|*ultimate*)
								add_orig_url "${url}" "${entry}"
								replace_str url dnsmasq wildcard
								add_conv_url url ".txt" "-onlydomains.txt" "${entry}"
								e=1
					esac ;;
				*"${hagezi_dl_url}/domains/whitelist-referral"*) add_corr_url "${url}" allowlist; e=1 ;;
				*"${hagezi_dl_url}/ips/"*) add_corr_url "${url}" blocklist_ipv4; e=1 ;;
				*"oisd.nl/domainswild2"*) add_corr_url "${url}" "${entry}"; e=1 ;;
				*"oisd.nl/dnsmasq"*)
					add_orig_url "${url}" "${entry}"
					case "${url}" in
						*dnsmasq2*) p="/dnsmasq2" ;;
						*dnsmasq*) p="/dnsmasq"
					esac
					add_conv_url url "${p}" "/domainswild2" "${entry}"
					e=1
			esac
			[ -z "${e}" ] && { eval "unrec_${entry}_urls=\"\${unrec_${entry}_urls}${url} \""; url_conv_req=1; }
		done
	done
}

# @url_conversion_logic
# assemble new config settings out of ${conv_*_urls}, ${unrec_*_urls}, ${correct_*_urls} and assign to variables
convert_urls()
{
	local entry format urls
	for format in "" dnsmasq_
	do
		for entry_type in blocklist blocklist_ipv4 allowlist
		do
			entry_id="${format}${entry_type}_urls"

			case "${format}" in
				'') eval "${entry_id}=\"\${correct_${entry_type}_urls}\"" ;;
				dnsmasq_)
					eval "case \"\${${entry_id}}\" in ''|*\" \") ;; *) ${entry_id}=\"\${${entry_id}} \"; esac"
					eval "${entry_id}=\"\${${entry_id}}\${unrec_${entry_type}_urls} \""
			esac

			case "${1}" in
				y) [ -z "${format}" ] && eval "${entry_id}=\"\${${entry_id}}\${conv_${entry_type}_urls} \"" ;;
				n) [ -n "${format}" ] && eval "${entry_id}=\"\${${entry_id}}\${orig_${entry_type}_urls} \""
			esac

			eval "${entry_id}=\"\$(printf '%s\n' \${${entry_id}} | tr ' ' '\n' | sort -u | tr '\n' ' ')\"
				${entry_id}=\"\${${entry_id}% }\""
		done
	done
}

# validate config and assign to variables
#
# 1 - path to file
#
# return codes:
# 0 - Success
# 1 - Error
# 2 - Unexpected, missing or legacy-formatted (no double quotes) entries found
#
# sets ${missing_keys}, ${conf_fixes}, ${bad_value_keys}
# and variables for luci:
# *_curr_config_format *_def_config_format *_unexp_keys *_unexp_entries *_missing_keys *_missing_entries
# *_legacy_entries *_bad_conf_format *_conf_fixes *_bad_value_keys
parse_config()
{
	inval_e()
	{
		IFS="${default_IFS}"
		reg_failure "Invalid entry '$entry' in config."
	}

	add_conf_fix() { conf_fixes="${conf_fixes}${1}"$'\n'; }

	# Following 3 functions are needed to minimize ugly hacks and tinkering inside eval
	# shellcheck disable=SC2317
	parse_entry()
	{
		val=${entry#"${key}="}

		# Following 'case' is a temporary solution to allow easy config migration - remove a few months from now (Aug 2024)
		case "${entry}" in
			"compress_blocklist="?" #"*|"initial_dnsmasq_restart="?" #"*)
				legacy_entries="${legacy_entries}${entry}"$'\n'
				test_keys="${test_keys%%"${key}|"*}${test_keys#*"${key}|"}"
				val=${val%% *}
				return 0
		esac

		case "${val}" in
			*\"*\"*\"*) inval_e; return 1 ;; # do not allow more than 2 double-quote marks
			\"*\"*)
				local tmp_val="${val##*\"}" # remove value enclosed in double-quotes
				case "${tmp_val%%\#*}" in # do not allow characters between 2nd double-quote and in-line comment
					'') ;;
					*[!\ ${tab}]*) inval_e; return 1
				esac
				;;
			*\"*\"*) inval_e; return 1 ;; # double quote mark must be the first character
			*\"*) inval_e; return 1 ;; # do not allow 1 double-quote mark
			*"#"*) inval_e; return 1 ;; # do not allow in-line comments without double-quote marks
			*) legacy_entries="${legacy_entries}${entry}"$'\n'
		esac
		val=${val#\"}
		val=${val%\"*} # throw away everything after the 2nd double-quote mark
		test_keys="${test_keys%%"${key}|"*}${test_keys#*"${key}|"}" # remove current key from test_keys
	}

	add_unexp_entry()
	{
		unexp_keys="${unexp_keys}${key} "
		unexp_entries="${unexp_entries}${entry}"$'\n'
	}

	check_val()
	{
		eval "case \"${val}\" in
			${valid_values}) return 0
			esac"

		bad_val_entries="${bad_val_entries}${entry} (should be $(print_def_config -d | \
			sed -n "/^[ \t]*${key}[ \t]*=/{s/^.*@[ \t]*//;s/[ \t]//g;s/|/ or /g;s/''/empty string/;s/integer/non-negative integer/;p;q;}"))"$'\n'
		bad_value_keys="${bad_value_keys}${key}|"
		return 1
	}

	local def_config='' curr_config='' missing_entries='' unexp_keys='' unexp_entries='' legacy_entries='' \
		test_keys entry key val bad_val_entries='' corrected_entries='' \
		tab="$(printf '\t')" sed_conf_san_exp='/^[ \t]*#.*$/d; s/^[ \t]*//; s/[ \t]*$//; /^$/d'

	unset curr_config_format def_config_format bad_value_keys \
		luci_curr_config_format luci_def_config_format luci_unexp_keys luci_unexp_entries luci_missing_keys luci_missing_entries \
		luci_legacy_entries luci_bad_conf_format luci_conf_fixes preset

	[ -z "${1}" ] && { reg_failure "parse_config(): no file specified."; return 1; }

	[ ! -f "${1}" ] && { reg_failure "Config file '${1}' not found."; return 1; }

	# determine recommended preset
	case "${luci_preset}" in
		''|auto) mk_def_preset || { print_msg "Falling back to preset 'small'."; preset=small; } ;;
		*) preset="${luci_preset}"
	esac

	# extract entries from default config
	def_config="$(print_def_config)" || return 1

	# extract valid values from default config
	local sed_valid_vals_expr="/^[^@]*$/d; s/=.*@[ \t]*/=/; /=[ \t]*$/d; /\"/d; s/[ \t]//g; s/^/val_/; s/=string/=*/; \
		s/=integer/=*[!0-9]*|'') ;; */; s/=/=\"/; s/$/\"/"
	local all_valid_values="$(print_def_config -d | sed "${sed_conf_san_exp};${sed_valid_vals_expr}")"
	# assign 'val_*' variables
	eval "${all_valid_values}" || exit 1

	# extract keys from default config, convert to '|' separated list
	# 'dummy|' is needed to avoid errors in eval
	test_keys="dummy|$(printf '%s\n' "${def_config}" | sed "${sed_conf_san_exp};"'s/=.*//' | tr '\n' '|')"

	# read and sanitize current config
	curr_config="$(sed "${sed_conf_san_exp}" "${1}")" || { reg_failure "Failed to read the config file '${1}'."; return 1; }

	# get config versions
	curr_config_format="$(get_config_format "${1}")"
	luci_curr_config_format=${curr_config_format}
	def_config_format="$(printf %s "${def_config}" | get_config_format)"
	luci_def_config_format=${def_config_format}

	local IFS=$'\n'
	for entry in ${curr_config}
	do
		case ${entry} in
			*?=*) ;;
			*) { inval_e; return 1; } ;;
		esac
		key="${entry%%=*}"
		case "${key}" in *[!A-Za-z0-9_]*) inval_e; return 1; esac
		# check if the key is in the default keys list, assign value to var if so
		eval "case \"${key}\" in
				${test_keys%|})
					parse_entry || return 1
					valid_values=\"\${val_${key}}\"
					[ -z \"\${valid_values}\" ] && { reg_failure \"Config key '${key}' has no assigned valid values.\"; exit 1; }
					check_val && ${key}"='${val}'" ;;
				*) add_unexp_entry
			esac"
	done

	IFS="${default_IFS}"

	if [ -n "${unexp_entries}" ]
	then
		reg_failure "Unexpected keys in config: '${unexp_keys% }'."
		print_msg "Corresponding config entries:" "${unexp_entries%$'\n'}"
		add_conf_fix "Remove unexpected entries from the config"
		luci_unexp_keys=${unexp_keys% }
		luci_unexp_entries=${unexp_entries%$'\n'}
	fi

	# @url_conversion_logic
	# check if urls need conversion, generate converted urls if so
	if [ "${action}" != gen_config ] && [ -z "${urls_converted}" ] && [ ! -f "${config_dir}/.new_urls_format" ]
	then
		mk_conv_urls
		if [ -n "${url_conv_req}" ]
		then
			luci_url_conv_req=1
			test_keys="$(printf %s "${test_keys}" | sed -E 's~(dnsmasq_){0,1}(block|allow)list(_ipv4){0,1}_urls[|]~~g')"
		else
			mk_new_urls_format_flag || return 1
		fi
	fi

	test_keys=${test_keys#dummy|}
	if [ -n "${test_keys}" ]
	then
		missing_entries="$(printf %s "${def_config}" | grep -E "^(${test_keys%|})=")"
		missing_keys="$(printf %s "${test_keys}" | tr '|' ' ')"
		reg_failure "Missing keys in config: '${missing_keys% }'."
		print_msg "Corresponding default config entries:" "${missing_entries}"
		add_conf_fix "Re-add missing config entries with default values"
		luci_missing_keys=${missing_keys% }
		luci_missing_entries=${missing_entries}
	fi

	if [ -n "${legacy_entries}" ]
	then
		reg_failure "Detected config entries in legacy format (missing double-quotes)."
		print_msg "The following config entries must be converted to the new config format:" "${legacy_entries%$'\n'}"
		add_conf_fix "Convert legacy config entries to the new format"
		luci_legacy_entries=${legacy_entries%$'\n'}
	fi

	if [ -n "${bad_value_keys}" ]
	then
		corrected_entries="$(printf %s "${def_config}" | grep -E "^(${bad_value_keys%|})=")"
		bad_value_keys="$(printf %s "${bad_value_keys}" | tr '|' ' ')"
		reg_failure "Detected config entries with unexpected values."
		print_msg "The following config entries have unexpected values:" "${bad_val_entries%$'\n'}" "" \
			"Corresponding default config entries:" "${corrected_entries}"
		add_conf_fix "Replace unexpected values with defaults"
		luci_bad_val_entries=${bad_val_entries%$'\n'}
		luci_corrected_entries=${corrected_entries%$'\n'}
	fi

	if [ -z "${conf_fixes}" ] && [ -z "${url_conv_req}" ]
	then
		case "${curr_config_format}" in
			*[!0-9]*|'')
				log_msg -warn "" "Config format version is unknown or invalid."
				add_conf_fix "Update config format version" ;;
			*)
				if [ "${curr_config_format}" -lt "${def_config_format}" ]
				then
					log_msg -yellow "" "Current config format version '${curr_config_format}' is older than default config version '${def_config_format}'."
					add_conf_fix "Update config format version"
				fi
		esac
	fi

	# @config_migration_logic
	# config file path change code can be removed a few months from now (Sep 2024)
	if [ "${actual_config_file}" = "${root_config_file}" ]
	then
		log_msg -yellow "" "Note: config file path has changed to ${config_file}." "Your config file ${actual_config_file} will need to be moved."
		add_conf_fix "Move the config file to ${config_file}"
		luci_config_path_changed=1
	fi

	conf_fixes="${conf_fixes%$'\n'}"
	luci_conf_fixes="${conf_fixes}"

	{ [ -n "${url_conv_req}" ] && [ -z "${urls_converted}" ]; } || # @url_conversion_logic
	[ -n "${conf_fixes}" ] && return 2
	:
}

# @url_conversion_logic
mk_new_urls_format_flag()
{
	try_mkdir -p "${config_dir}" || return 1
	[ -f "${config_dir}/.new_urls_format" ] && return 0
	touch "${config_dir}/.new_urls_format" || { reg_failure "Failed to create file '${config_dir}/.new_urls_format'."; return 1; }
	:
}

# shellcheck disable=SC2120
# 1 - (optional) '-f' to force fixing the config if it has issues
load_config()
{
	local actual_config_file conf_fixes='' fixed_config='' missing_keys='' bad_value_keys='' key val line fix cnt parse_res url_conv_req

	# Need to set do_dialogs here for compatibility when updating from earlier versions
	local do_dialogs=
	[ -z "${luci_skip_dialogs}" ] && [ "${msgs_dest}" = "/dev/tty" ] && do_dialogs=1

	# @config_migration_logic
	if [ -f "${config_file}" ]
	then
		actual_config_file="${config_file}"
	elif [ -f "${root_config_file}" ]
	then
		actual_config_file="${root_config_file}"
	else
		reg_failure "Config file is missing."
		log_msg "Generate default config using 'service adblock-lean gen_config'."
		return 1
	fi

	local tip_msg="Fix your config file '${actual_config_file}' or generate default config using 'service adblock-lean gen_config'."

	# validate config and assign to variables
	parse_config "${actual_config_file}"
	parse_res=${?}
	[ ${parse_res} = 1 ] && { log_msg "${tip_msg}"; return 1; }

	[ ${parse_res} = 0 ] && [ -z "${url_conv_req}" ] && return 0

	# if not in interactive console, return error
	[ -z "${do_dialogs}" ] && [ "${1}" != '-f' ] && { log_msg "${tip_msg}"; return 1; }

	# sanity check
	[ -z "${conf_fixes}" ] && [ -z "${url_conv_req}" ] && { reg_failure "Failed to parse config."; return 1; }

	if [ -n "${do_dialogs}" ] && [ "${1}" != '-f' ]
	then
		if [ -n "${conf_fixes}" ]
		then
			print_msg "" "${blue}Perform following automatic changes?${n_c}"
			cnt=0
			local IFS=$'\n'
			for fix in ${conf_fixes}
			do
				[ -z "${fix}" ] && continue
				cnt=$((cnt+1))
				print_msg "${cnt}. ${fix}"
			done
			IFS="${default_IFS}"
			pick_opt "y|n" || return 1
			[ "${REPLY}" = n ] && { log_msg "${tip_msg}"; return 1; }
		fi

		# @url_conversion_logic
		if [ -n "${url_conv_req}" ]
		then
			print_msg "" "${purple}NOTE: adblock-lean now supports both dnsmasq-formatted lists and \"raw domain\" lists.${n_c}" \
				"The \"raw domain\" lists are functionally identical but their filesize is smaller and they are faster to process." \
				"Hagezi and OISD dnsmasq-formatted list URLs can be automatically converted to \"raw domain\" list URLs." \
				"If you are using other dnsmasq-formatted lists, they will be moved into separate config options and continue to work," \
				"but you may want to look for their raw domain equivalents (sometimes called \"wildcard domains\")." \
				"" "${purple}Current \"raw domains\" URL config entries:${n_c}" "${curr_url_entries%"${nl}"}"
			[ -n "${curr_dnsmasq_url_entries%"${nl}"}" ] &&
				print_msg "" "${purple}Current \"dnsmasq\" URL config entries:${n_c}" "${curr_dnsmasq_url_entries%"${nl}"}"
			if [ -n "${conv_blocklist_urls}${conv_blocklist_ipv4_urls}${conv_allowlist_urls}" ]
			then
				print_msg "" "${purple}Convert known dnsmasq-formatted list URLs which are currently configured as \"raw domains\" to \"raw domain\" list URLs?${n_c}" \
						"(you will be asked to confirm before writing the config)"
				pick_opt "y|n" || return 1
			else
				REPLY=y
			fi
			convert_urls "${REPLY}"
			urls_converted=1

			for list_format in "\"raw domain\"" dnsmasq
			do
				print_msg "" "${purple}Updated ${list_format} URL config entries:${n_c}"
				if [ "${list_format}" = "\"raw domain\"" ]
				then
					list_format=
				else
					list_format=dnsmasq_
				fi
				for url_entry in "${list_format}blocklist" "${list_format}blocklist_ipv4" "${list_format}allowlist"
				do
					eval "urls=\"\${${url_entry}_urls}\""
					print_msg "${blue}${url_entry}_urls${n_c}=\"${urls}\""
				done
			done
			print_msg "" "Confirm URLs update in config?"
			pick_opt "y|n" || return 1
			[ "${REPLY}" = n ] && { log_msg "${tip_msg}"; return 1; }
		fi
	fi

	fix_config "${missing_keys} ${bad_value_keys}" || { reg_failure "Failed to fix the config."; log_msg "${tip_msg}"; return 1; }
	mk_new_urls_format_flag || return 1 # @url_conversion_logic
	:
}

# 1 - missing keys (whitespace-separated)
fix_config()
{
	local missing_keys="${1}"

	# recreate config from default while replacing values with values from the existing config
	fixed_config="$(
		IFS=$'\n'
		print_def_config | while read -r line
		do
			case ${line} in
				\#*|'') printf '%s\n' "${line}"; continue ;;
				*=*)
					key=${line%%=*}
					case " ${missing_keys} " in
						*" ${key} "*) printf '%s\n' "${line}"; continue ;;
						*)
							eval "val=\"\${${key}}\""
							printf '%s\n' "${key}=\"${val}\""
							continue
					esac
			esac
		done
	)"

	local old_config_f="/tmp/adblock-lean_config.old"
	if ! cp "${actual_config_file}" "${old_config_f}"
	then
		reg_failure "Failed to save old config file as ${old_config_f}."
		[ -z "${do_dialogs}" ] && return 1
		log_msg "Proceed with suggested config changes?"
		pick_opt "y|n" || return 1
		[ "${REPLY}" = n ] && return 1
	else
		log_msg "" "Old config file was saved as ${old_config_f}."
	fi

	write_config "${fixed_config}" || return 1

	:
}

# Writes config to temp file, validates it, moves it to permanent storage
# 1 - new config file contents
write_config()
{
	local tmp_config="${abl_dir}/write-config.tmp" missing_keys conf_fixes

	[ -z "${1}" ] && { reg_failure "write_config(): no config passed."; return 1; }

	try_mkdir -p "${abl_dir}" || return 1
	printf '%s\n' "${1}" > "${tmp_config}" || { reg_failure "Failed to write to file '${tmp_config}'."; return 1; }
	local actual_config_file="${config_file}"
	parse_config "${tmp_config}" ||
		{ rm -f "${tmp_config}"; reg_failure "Failed to validate the new config."; return 1; }

	log_msg "" "Saving new config file to '${config_file}'."
	try_mkdir -p "${config_dir}" || return 1
	try_mv "${tmp_config}" "${config_file}" &&
	# @config_migration_logic, also the '&&' above
	{ rm -f "${root_config_file}"; return 0; }

	rm -f "${tmp_config}"
	return 1
}

# return codes:
# 0 - running
# 1,2 - (reserved)
# 3 - paused
# 4 - stopped
get_abl_run_state()
{
	local f
	for f in "${dnsmasq_tmp_d}/.blocklist.gz" "${dnsmasq_tmp_d}/blocklist"
	do
		[ -f "${f}" ] && return 0
	done

	[ -f "${abl_dir}/prev_blocklist.gz" ] && return 3
	return 4
}

clean_dnsmasq_dir()
{
	rm -f "${dnsmasq_tmp_d}"/.blocklist.gz "${dnsmasq_tmp_d}"/blocklist "${dnsmasq_tmp_d}"/conf-script "${dnsmasq_tmp_d}"/.extract_blocklist
}

# exit with code ${1}
# if function 'abl_luci_exit' is defined, execute it before exit
cleanup_and_exit()
{
	trap - INT TERM EXIT
	[ -n "${cleanup_req}" ] && rm -rf "${abl_dir}"
	[ -n "${lock_req}" ] && rm_lock
	local recent_log=
	[ -n "${log_file}" ] && [ -s "${log_file}" ] && read -rd '' recent_log < "${log_file}"
	luci_log="${recent_log}"
	if [ -z "${luci_sourced}" ] && [ -n "${failure_msg}" ] && [ -n "${custom_scr_sourced}" ] && command -v report_failure 1>/dev/null
	then
		[ -n "${recent_log}" ] && failure_msg="${failure_msg}"$'\n'$'\n'"Session log:"$'\n'"${recent_log}"
		report_failure "${failure_msg}"
	fi
	[ -n "${luci_sourced}" ] && abl_luci_exit "${1}"
	exit "${1}"
}

reg_failure()
{
	log_msg -err "" "${1}"
	failure_msg="${failure_msg}${1}"$'\n'
	luci_errors="${failure_msg}"
}

log_success()
{
	log_msg "${1}"
	success_msg="${1}"
	local recent_log=
	[ -n "${log_file}" ] && [ -s "${log_file}" ] && read -rd '' recent_log < "${log_file}"
	[ -n "${recent_log}" ] && success_msg="${success_msg}"$'\n'$'\n'"Session log:"$'\n'"${recent_log}"
	if [ -n "${custom_scr_sourced}" ] && command -v report_success 1>/dev/null
	then
		report_success "${1}"
	fi
}

try_export_existing_blocklist()
{
	export_existing_blocklist
	case ${?} in
		1) reg_failure "Failed to export the blocklist."; return 1 ;;
		2) return 2
	esac
	:	
}

# return codes:
# 0 - addnmount entry exists
# 1 - addnmount entry doesn't exist
# 2 - uci command not found
check_addnmount()
{
	hash uci 1>/dev/null || { reg_failure "uci command was not found."; return 2; }
	local i=0
	while uci -q get dhcp.@dnsmasq[${i}] >/dev/null && [ ${i} -lt 128 ]
	do
		uci -q get dhcp.@dnsmasq[${i}].addnmount
		i=$((i+1))
	done | grep -qE "(^|[ \t])/bin(/\*|/busybox)*($|[ \t])" && return 0
	return 1
}

# return codes:
# 0 - addnmount entry exists
# 1 - addnmount entry doesn't exist
# 2 - uci command not found
check_blocklist_compression_support()
{
	if ! dnsmasq --help | grep -qe "--conf-script"
	then
		log_msg "" "Note: The version of dnsmasq installed on this system does not support blocklist compression." \
			"Blocklist compression support in dnsmasq can be verified by checking the output of: dnsmasq --help | grep -e \"--conf-script\"" \
			"To use dnsmasq compression (which saves memory), upgrade OpenWrt and/or dnsmasq to a newer version that supports blocklist compression."
		return 1
	fi

	check_addnmount && return 0
	[ ${?} = 2 ] && return 2
	log_msg -warn "" "No appropriate 'addnmount' entry in /etc/config/dhcp was identified." \
		"Final blocklist compression will be disabled."
	log_msg "addnmount entry is required to give dnsmasq access to busybox gunzip in order to extract compressed blocklist." \
		"Run 'service adblock-lean setup' to have the entry created automatically, or follow the steps in the README." \
		"Alternatively, change the 'use_compression' option in adblock-lean config to '0'."
	return 1
}

cleanup_dl_status_files()
{
	rm -f "${abl_dir}/rogue_element" "${abl_dir}/uclient-fetch_err"
}

# 1 - list id
# 2 - list type (allowlist|blocklist|blocklist_ipv4)
# 3 - list origin (local or downloaded)
# 4 - list format (dnsmasq or raw)
# 5 - local list path (for local lists) or URL (for downloaded lists)
#
# return codes:
# 0 - Success
# 1 - General error (stop processing)
# 2 - Bad List (retry doesn't make sense)
# 3 - Download Failure (retry makes sense)
process_list_part()
{
	local list_id="${1}" list_type="${2}" list_origin="${3}" list_format="${4}" list_path="${5}" me="process_list_part" \
		dest_file="${abl_dir}/${list_type}.${list_id}" compress_part='' \
		min_list_part_line_count='' list_part_size_B='' list_part_size_KB='' val_entry_regex

	for v in 1 2 3 4 5; do
		eval "[ -z \"\${${v}}\" ]" && { reg_failure "${me}: Missing arguments."; return 1; }
	done

	case "${list_type}" in
		allowlist|blocklist) val_entry_regex='^(\*|[[:alnum:]_-]+)([.][[:alnum:]_-]+)+$' ;;
		blocklist_ipv4) val_entry_regex='^((25[0-5]|(2[0-4]|1[0-9]|[1-9]|)[0-9])\.){3}(25[0-5]|(2[0-4]|1[0-9]|[1-9]|)[0-9])$' ;;
		*) reg_failure "${me}: Invalid list type '${list_type}'"; return 1
	esac

	case ${list_type} in
		allowlist) dest_file="${abl_dir}/allowlist.0" ;;
		blocklist|blocklist_ipv4) [ "${use_compression}" = 1 ] && { dest_file="${dest_file}.gz"; compress_part=1; }
	esac

	eval "min_list_part_line_count=\"\${min_${list_type}_part_line_count}\""

	cleanup_dl_status_files

	# Download or cat the list
	case "${list_origin}" in
		downloaded) uclient-fetch "${list_path}" -O- --timeout=3 2> "${abl_dir}/uclient-fetch_err";;
		local) cat "${list_path}"
	esac |
	# limit size
	{ head -c "${max_file_part_size_KB}k"; cat 1>/dev/null; } |

	# Count bytes
	tee >(wc -c > "${abl_dir}/list_part_size_B") |

	# Remove comment lines and trailing comments, remove whitespaces
	sed 's/#.*$//; s/^[ \t]*//; s/[ \t]*$//; /^$/d' |

	# Convert dnsmasq format to raw format
	if [ "${list_format}" = dnsmasq ]
	then
		local rm_prefix_expr="s~^[ \t]*(local|server|address)=/~~" rm_suffix_expr=''
		case "${list_type}" in
			blocklist) rm_suffix_expr='s~/$~~' ;;
			blocklist_ipv4) rm_prefix_expr="s~^[ \t]*bogus-nxdomain=~~" ;;
			allowlist) rm_suffix_expr='s~/#$~~'
		esac
		sed -E "${rm_prefix_expr};${rm_suffix_expr}" | tr '/' '\n'
	else
		cat
	fi |

	# Count entries
	tee >(wc -w > "${abl_dir}/list_part_line_count") |

	# Convert to lowercase
	case "${list_type}" in allowlist|blocklist) tr 'A-Z' 'a-z' ;; *) cat; esac |

	if [ "${list_type}" = blocklist ] && [ "${use_allowlist}" = 1 ]
	then
		case "${whitelist_mode}" in
		0)
			# remove allowlist domains from blocklist
			${awk_cmd} 'NR==FNR { allow[$0]; next } { n=split($1,arr,"."); addr = arr[n];
				for ( i=n-1; i>=1; i-- ) { addr = arr[i] "." addr; if ( addr in allow ) next } } 1' "${abl_dir}/allowlist" - ;;
		1)
			# only print subdomains of allowlist domains
			${awk_cmd} 'NR==FNR { allow[$0]; next } { n=split($1,arr,"."); addr = arr[n];
				for ( i=n-1; i>1; i-- ) { addr = arr[i] "." addr; if ( addr in allow ) { print $1; next } } }' "${abl_dir}/allowlist" -
		esac
	else
		cat
	fi |

	# check lists for rogue elements
	tee >(sed -nE "\~${val_entry_regex}~d;p;:1 n;b1" > "${abl_dir}/rogue_element") |

	# compress parts
	if [ -n "${compress_part}" ]
	then
		gzip
	else
		cat
	fi > "${dest_file}"

	read -r list_part_size_B _ < "${abl_dir}/list_part_size_B" 2>/dev/null
	list_part_size_KB=$(( (list_part_size_B + 0) / 1024 ))
	list_part_size_human="$(bytes2human "${list_part_size_B:-0}")"
	read -r list_part_line_count _ < "${abl_dir}/list_part_line_count" 2>/dev/null
	: "${list_part_line_count:=0}"

	rm -f "${abl_dir}/list_part_size_B" "${abl_dir}/list_part_line_count"

	if [ "${list_part_size_KB}" -ge "${max_file_part_size_KB}" ]
	then
		reg_failure "${list_origin} ${list_type} part size reached the maximum value set in config (${max_file_part_size_KB} KB)."
		log_msg "Consider either increasing this value in the config or removing the corresponding ${list_type} part path or URL from config."
		rm -f "${dest_file}"
		return 2
	fi

	if [ "${list_origin}" = downloaded ] && ! grep -q "Download completed" "${abl_dir}/uclient-fetch_err"
	then
		rm -f "${dest_file}"
		reg_failure "Download of new ${list_type} file part from: ${list_path} failed."
		return 3
	fi

	if [ "${list_origin}" = downloaded ] && read -r rogue_element < "${abl_dir}/rogue_element"
	then
		rm -f "${dest_file}"
		log_msg -warn "Rogue element: '${rogue_element}' identified originating in ${list_type} file part from: ${list_path}."
		return 2
	fi
	rm -f "${abl_dir}/rogue_element"

	if [ "${list_origin}" = downloaded ] && [ "${list_part_line_count}" -lt "${min_list_part_line_count}" ]
	then
		rm -f "${dest_file}"
		reg_failure "Downloaded ${list_type} part line count: $(int2human ${list_part_line_count}) less than configured minimum: $(int2human ${min_list_part_line_count})."
		return 3
	fi

	# keep the allowlist consolidated in one file
	if [ "${list_type}" = allowlist ]
	then
		cat "${dest_file}" >> "${abl_dir}/allowlist" || { reg_failure "Failed to merge allowlist part."; return 1; }
		rm -f "${dest_file}"
	fi

	cleanup_dl_status_files
	:
}

test_url_domains()
{
	local urls list_type list_format d domains='' dom IFS="${default_IFS}"
	for list_type in allowlist blocklist blocklist_ipv4
	do
		for list_format in raw dnsmasq
		do
			d=
			[ "${list_format}" = dnsmasq ] && d="dnsmasq_"
			eval "urls=\"\${${d}${list_type}_urls}\""
			[ -z "${urls}" ] && continue
			domains="${domains}$(printf %s "${urls}" | tr ' \t' '\n' | sed -n '/http/{s~^http[s]*[:]*[/]*~~g;s~/.*~~;/^$/d;p;}')${nl}"
		done
	done
	[ -z "${domains}" ] && return 0

	for dom in $(printf %s "${domains}" | sort -u)
	do
		try_lookup_domain "${dom}" || return 1
	done
	:
}

gen_list_parts()
{
	# 1 - list origin (local or downloaded)
	log_process_success()
	{
		local part=
		[ "${1}" = downloaded ] && part=" part"
		log_msg "Successfully processed ${list_type}${part} (source file size: ${list_part_size_human}, sanitized line count: $(int2human ${list_part_line_count}))."
	}

	handle_process_failure()
	{
		[ "${list_part_failed_action}" = "STOP" ] && { log_msg "list_part_failed_action is set to 'STOP', exiting."; return 1; }
		log_msg "Skipping file and continuing."
		:
	}

	local list_type='' list_format='' list_id list_line_cnt list_part_line_count and_compressing='' list_urls list_url local_list_path

	[ -z "${blocklist_urls}${dnsmasq_blocklist_urls}" ] && log_msg -yellow "" "NOTE: No URLs specified for blocklist download."

	rm -f "${abl_dir}/allowlist"

	if [ "${whitelist_mode}" = 1 ]
	then
		# allow test domains
		for d in ${test_domains}
		do
			printf '%s\n' "${d}" >> "${abl_dir}/allowlist"
		done
		use_allowlist=1
	fi

	for list_type in allowlist blocklist blocklist_ipv4
	do
		rm -f "${abl_dir}/${list_type}".*
		list_id=0 list_line_cnt=0 list_part_line_count=0
		and_compressing=
		case ${list_type} in blocklist|blocklist_ipv4) [ "${use_compression}" = 1 ] && and_compressing=" and compressing"; esac

		# Local list
		if [ "${list_type}" != blocklist_ipv4 ]
		then
			eval "local_list_path=\"\${local_${list_type}_path}\""
			if [ ! -f "${local_list_path}" ]
			then
				log_msg -blue "No local ${list_type} identified."
			elif [ ! -s "${local_list_path}" ]
			then
				log_msg -warn "Local ${list_type} file is empty."
			else
				log_msg -blue "" "Found local ${list_type}. Sanitizing${and_compressing}."
				reg_action -nolog "Sanitizing${and_compressing} the local ${list_type}." || return 1
				process_list_part "${list_id}" "${list_type}" "local" "raw" "${local_list_path}"
				case ${?} in
					0)
						log_process_success "local"
						list_line_cnt=$(( list_line_cnt + list_part_line_count )) ;;
					*) handle_process_failure || return 1
				esac
			fi
		fi

		# List parts download

		for list_format in raw dnsmasq
		do
			local d=
			local invalid_urls='' bad_hagezi_urls=''
			[ "${list_format}" = dnsmasq ] && d="dnsmasq_"

			eval "list_urls=\"\${${d}${list_type}_urls}\""
			[ -z "${list_urls}" ] && continue

			reg_action -blue "Starting ${list_format} ${list_type} part(s) download." || return 1

			invalid_urls="$(printf %s "${list_urls}" | tr ' ' '\n' | grep -E '^(http[s]*://)*(www\.)*github\.com')" &&
				log_msg -warn "" "Invalid URLs detected:" "${invalid_urls}"

			if [ "${list_format}" = raw ]
			then
				bad_hagezi_urls="$(printf %s "${list_urls}" | tr ' ' '\n' | grep '/hagezi/.*/dnsmasq/')" &&
				log_msg -warn "" "Following Hagezi URLs are in dnsmasq format and should be either changed to raw list URLs" \
					"or moved to one of the 'dnsmasq_' config entries:" "${bad_hagezi_urls}"
				case "${list_type}" in blocklist|allowlist)
					bad_hagezi_urls="$(printf %s "${list_urls}" | tr ' ' '\n' | sed -n '/\/hagezi\//{/onlydomains\./d;/^$/d;p;}')"
					[ -n "${bad_hagezi_urls}" ] && log_msg -warn "" \
						"Following Hagezi URLs are missing the '-onlydomains' suffix in the filename:" "${bad_hagezi_urls}"
				esac
			fi

			for list_url in ${list_urls}
			do
				list_id=$((list_id+1))
				retry=0
				while :
				do
					retry=$((retry + 1))
					list_part_line_count=0
					reg_action "Downloading, checking and sanitizing ${list_format} ${list_type} part from: ${list_url}." || return 1
					process_list_part "${list_id}" "${list_type}" "downloaded" "${list_format}" "${list_url}"
					case ${?} in
						0)
							log_process_success "downloaded ${list_format}"
							[ "${list_type}" = blocklist_ipv4 ] && use_blocklist_ipv4=1
							list_line_cnt=$(( list_line_cnt + list_part_line_count ))
							continue 2 ;;
						1) return 1 ;;
						2)
							handle_process_failure || return 1
							continue 2 ;;
						3)
					esac

					if [ "${retry}" -ge "${max_download_retries}" ]
					then
						reg_failure "Three download attempts failed for URL ${list_url}."
						handle_process_failure || return 1
						continue 2
					fi

					reg_action -blue "Sleeping for 5 seconds after failed download attempt." || return 1
					sleep 5
					continue
				done
			done
		done

		if [ "${list_line_cnt}" = 0 ] || { [ "${list_type}" = allowlist ] && [ ! -f "${abl_dir}/allowlist" ]; }
		then
			case ${list_type} in
				blocklist)
					[ "${whitelist_mode}" = 0 ] && return 1
					log_msg -yellow "Whitelist mode is on - accepting empty blocklist." ;;
				allowlist)
					log_msg "Not using any allowlist for blocklist processing."
					use_allowlist=0
					continue ;;
				blocklist_ipv4) use_blocklist_ipv4=0
			esac
		fi

		if [ "${list_type}" = allowlist ]
		then
			log_msg -green "" "Successfully generated allowlist with $(int2human ${list_line_cnt}) entries."
			log_msg "Will remove any (sub)domain matches present in the allowlist from the blocklist and append corresponding server entries to the blocklist."
			use_allowlist=1
		fi
		preprocessed_list_line_cnt="$((preprocessed_list_line_cnt+list_line_cnt))"
	done
	:
}

generate_and_process_blocklist_file()
{
	convert_entries()
	{
		if [ "${awk_cmd}" = gawk ]
		then
			pack_entries_awk "$@"
		else
			pack_entries_sed "$@"
		fi
	}

	# convert to dnsmasq format and pack 4 input lines into 1 output line
	# intput from STDIN, output to STDIN
	# 1 - blocklist|allowlist
	pack_entries_sed()
	{
		local entry_type
		case "$1" in
			blocklist)
				# packs 4 domains in one 'local=/.../' line
				sed "/^$/d;s~^.*$~local=/&/~;\$!{n;a /${nl}};\$!{n;a /${nl}};\$!{n; a /${nl}};a @" ;;
			allowlist)
				# packs 4 domains in one 'server=/.../#'' line
				{ cat; printf '\n'; } | sed '/^$/d;$!N;$!N;$!N;s~\n~/~g;s~^~server=/~;s~/*$~/#@~' ;;
			*) printf ''; return 1
		esac | tr -d '\n' | tr "@" '\n'
	}

	# convert to dnsmasq format and pack input lines into 1024 characters-long lines
	# intput from STDIN, output to STDOUT
	# 1 - blocklist|allowlist
	pack_entries_awk()
	{
		local entry_type len_lim=1024 allow_char=''
		case "$1" in
			blocklist) entry_type=local ;;
			allowlist) entry_type=server allow_char="#" ;;
		esac

		len_lim=$((len_lim-${#entry_type}-${#allow_char}-2))
		# shellcheck disable=SC2016
		$awk_cmd -v ORS="" -v m=${len_lim} -v a="${allow_char}" -v t=${entry_type} '
			BEGIN {al=0; r=0; s=""}
			NF {
				r=r+1
				if (r==1) {print t "=/"}
				l=length($0)
				n=al+1+l
				if (n<=m) {al=n; print $0 "/"; next}
				else {print a "\n" t "=/" $0 "/"; al=l+1}
			}
			END {print a "\n"}'
	}

	# 1 - list type (blocklist|blocklist_ipv4)
	print_list_parts()
	{
		local find_name="${1}.[0-9]*" find_cmd="cat"
		[ "${use_compression}" = 1 ] && { find_name="${1}.*.gz" find_cmd="gunzip -c"; }
		find "${abl_dir}" -name "${find_name}" -exec ${find_cmd} {} \; -exec rm -f {} \;
		printf ''
	}

	# 1 - list type (block|blocklist_ipv4|allowlist)
	read_list_stats()
	{
		read -r ${1}_entries_cnt ${1}_size_B 2>/dev/null < "${abl_dir}/${1}_stats"
		eval ": \"\${${1}_entries_cnt:=0}\" \"\${${1}_size_B:=0}\""
	}

	dedup()
	{
		if [ "${deduplication}" = 1 ]
		then
			sort -u -
		else
			cat
		fi
	}

	reg_action -blue "Sorting and merging the blocklist parts into a single blocklist file." || return 1

	local list_type out_f="${abl_dir}/blocklist"

	[ -n "${final_compress}" ] && out_f="${out_f}.gz"

	rm -f "${abl_dir}/dnsmasq_err"

	{
		# print blocklist parts
		print_list_parts blocklist |
		# optional deduplication
		dedup |
		# count entries
		tee >(wc -wc > "${abl_dir}/blocklist_stats") |
		# pack entries in 1024 characters long lines
		convert_entries blocklist

		# print ipv4 blocklist parts
		if [ "${use_blocklist_ipv4}" ]
		then
			print_list_parts blocklist_ipv4 |
			# optional deduplication
			dedup |
			tee >(wc -wc > "${abl_dir}/blocklist_ipv4_stats") |
			# add prefix
			sed 's/^/bogus-nxdomain=/'
		fi

		# print allowlist parts
		if [ "${use_allowlist}" = 1 ]
		then
			cat "${abl_dir}/allowlist" |
			# optional deduplication
			dedup |
			tee >(wc -wc > "${abl_dir}/allowlist_stats") |
			# pack entries in 1024 characters long lines
			convert_entries allowlist
			rm -f "${abl_dir}/allowlist"
		fi
		# add the optional whitelist entry
		if [ "${whitelist_mode}" = 1 ]
		then
			# add block-everything entry: local=/*a/*b/*c/.../*z/
			printf 'local=/'
			awk 'BEGIN{for (i=97; i<=122; i++) printf("*%c/",i);exit}'
			printf '\n'
		fi
		# add the blocklist test entry
		printf '%s\n' "address=/adblocklean-test123.info/#"
	} |

	# limit size
	{ head -c "${max_blocklist_file_size_KB}k"; cat 1>/dev/null; } |
	if  [ -n "${final_compress}" ]
	then
		gzip
	else
		cat
	fi > "${out_f}" || { reg_failure "Failed to write to output file '${out_f}'."; rm -f "${out_f}"; return 1; }

	reg_action -blue "Stopping dnsmasq." || return 1
	/etc/init.d/dnsmasq stop || { reg_failure "Failed to stop dnsmasq."; return 1; }

	# check the final blocklist with dnsmasq --test
	reg_action -blue "Checking the resulting blocklist with 'dnsmasq --test'." || return 1
	if  [ -n "${final_compress}" ]
	then
		gunzip -fc "${out_f}"
	else
		cat "${out_f}"
	fi |
	dnsmasq --test -C - 2> "${abl_dir}/dnsmasq_err"
	if [ ${?} != 0 ] || ! grep -q "syntax check OK" "${abl_dir}/dnsmasq_err"
	then
		local dnsmasq_err="$(head -n10 "${abl_dir}/dnsmasq_err" | sed '/^$/d')"
		rm -f "${out_f}" "${abl_dir}/dnsmasq_err"
		reg_failure "The dnsmasq test on the final blocklist failed."
		log_msg "dnsmasq --test errors:" "${dnsmasq_err:-"No specifics: probably killed because of OOM."}"
		return 2
	fi

	rm -f "${abl_dir}/dnsmasq_err"

	local blocklist_entries_cnt blocklist_size_B blocklist_ipv4_entries_cnt blocklist_ipv4_size_B allowlist_entries_cnt allowlist_size_B final_list_size_B

	for list_type in blocklist blocklist_ipv4 allowlist
	do
		read_list_stats ${list_type}
	done

	final_entries_cnt=$(( blocklist_entries_cnt + blocklist_ipv4_entries_cnt + allowlist_entries_cnt ))

	final_list_size_B=$(( blocklist_size_B + blocklist_ipv4_size_B + allowlist_size_B))
	final_list_size_human="$(bytes2human "${final_list_size_B}")"

	if [ $(( final_list_size_B / 1024 )) -ge "${max_blocklist_file_size_KB}" ]
	then
		reg_failure "Blocklist file size reached the maximum value set in config ($(int2human "${max_blocklist_file_size_KB}") KB)."
		log_msg "Consider either increasing this value in the config or changing the blocklist URLs."
		return 1
	fi

	if [ "${final_entries_cnt}" -lt "${min_good_line_count}" ]
	then
		reg_failure "Entries count ($(int2human "${final_entries_cnt}")) is below the minimum value set in config ($(int2human "${min_good_line_count}"))."
		return 1
	fi

	log_msg -green "New blocklist file check passed."
	log_msg "Final list uncompressed file size: ${final_list_size_human}."

	:
}


# return codes:
# 0 - dnsmasq running
# 1 - dnsmasq not running or failed to detect dnsmasq directory
# 2 - failed to detect dnsmasq directory
check_dnsmasq_instance()
{
	! pgrep -x /usr/sbin/dnsmasq &>/dev/null && return 1
	[ ! -d "${dnsmasq_tmp_d}" ] &&
		{ reg_failure "Directory '${dnsmasq_tmp_d}' does not exist. Failed to detect dnsmasq directory or dnsmasq is not running."; return 2; }
	:
}

try_lookup_domain()
{
	local ns_res
	ns_res="$(nslookup "${1}" 127.0.0.1 2>/dev/null)" ||
		{ reg_failure "Lookup of '${1}' failed."; return 2; }

	printf %s "${ns_res}" | grep -A1 ^Name | grep -qE '^(Address: *0\.0\.0\.0|Address: *127\.0\.0\.1)$' &&
		{ reg_failure "Lookup of '${1}' resulted in 0.0.0.0 or 127.0.0.1."; return 3; }
	:
}

# return values:
# 0 - dnsmasq is running, and all checks passed
# 1 - dnsmasq is not running
# 2 - dnsmasq is running, but one of the test domains failed to resolve
# 3 - dnsmasq is running, but one of the test domains resolved to 0.0.0.0
# 4 - dnsmasq is running, but the blocklist test domain failed to resolve (blocklist not loaded)
check_active_blocklist()
{
	reg_action -blue "Checking active blocklist." || return 1

	check_dnsmasq_instance || { [ ${?} = 1 ] && reg_failure "No running instance of dnsmasq detected."; return 1; }

	nslookup "adblocklean-test123.info" 127.0.0.1 1>/dev/null 2>/dev/null ||
			{ reg_failure "Lookup of the blocklist test domain failed with new blocklist."; return 4; }

	for domain in ${test_domains}
	do
		try_lookup_domain "${domain}" || return ${?}
	done

	:
}

restart_dnsmasq()
{
	reg_action -blue "Restarting dnsmasq." || return 1

	/etc/init.d/dnsmasq restart &> /dev/null || { reg_failure "Failed to restart dnsmasq."; stop 1; }
	
	reg_action -blue "Waiting for dnsmasq initialization." || return 1
	local dnsmasq_ok=
	for i in $(seq 1 60)
	do
		nslookup localhost 127.0.0.1 &> /dev/null && { dnsmasq_ok=1; break; }
		sleep 1;
	done

	[ -z "$dnsmasq_ok" ] && { reg_failure "dnsmasq initialization failed."; stop 1; }

	log_msg -green "Restart of dnsmasq completed."
	:
}

# return codes:
# 0 - success
# 1 - failure
# 2 - blocklist file not found (nothing to export)
export_existing_blocklist()
{
	reg_export()
	{
		reg_action -blue "Creating ${1} backup of existing blocklist." || return 1
	}

	local src src_d="${dnsmasq_tmp_d}" dest="${abl_dir}/prev_blocklist"
	if [ -f "${src_d}/.blocklist.gz" ]
	then
		case ${use_compression} in
			1)
				src="${src_d}/.blocklist.gz" dest="${dest}.gz"
				reg_export compressed || return 1 ;;
			*)
				reg_export uncompressed || return 1
				try_gunzip "${src_d}/.blocklist.gz" || { rm -f "${src_d}/.blocklist.gz"; return 1; }
				src="${src_d}/.blocklist"
		esac
	elif [ -f "${src_d}/blocklist" ]
	then
		if [ "${use_compression}" = 1 ]
		then
			reg_export compressed || return 1
			try_mv "${src_d}/blocklist" "${src_d}/.blocklist" || return 1
			try_gzip "${src_d}/.blocklist" || return 1
			src="${src_d}/.blocklist.gz" dest="${dest}.gz"
		else
			reg_export uncompressed || return 1
			src="${src_d}/blocklist"
		fi
	else
		log_msg "" "No existing compressed or uncompressed blocklist identified."
		return 2
	fi
	try_mv "${src}" "${dest}" || return 1
	:
}

restore_saved_blocklist()
{
	restore_failed()
	{
		reg_failure "Failed to restore saved blocklist."
	}

	local mv_src="${abl_dir}/prev_blocklist" mv_dest="${abl_dir}/blocklist"
	reg_action -blue "Restoring saved blocklist file." || { restore_failed; return 1; }
	if [ -f "${mv_src}.gz" ]
	then
		try_mv "${mv_src}.gz" "${mv_dest}.gz" || { restore_failed; return 1; }
		if [ -z "${final_compress}" ]
		then
			try_gunzip "${mv_dest}.gz" || { restore_failed; return 1; }
		fi
	elif [ -f "${mv_src}" ]
	then
		try_mv "${mv_src}" "${mv_dest}" || { restore_failed; return 1; }
		if [ -n "${final_compress}" ]
		then
			try_gzip -f "${mv_dest}" || { restore_failed; return 1; }
		fi
	else
		reg_failure "No previous blocklist file found."
		restore_failed
		return 1
	fi
	import_blocklist_file || { reg_failure "Failed to import the blocklist file."; restore_failed; return 1; }

	restart_dnsmasq || { restore_failed; return 1; }

	:
}

import_blocklist_file()
{
	local src src_compressed='' src_file="${abl_dir}/blocklist" dest_file="${dnsmasq_tmp_d}/blocklist"
	[ -n "${final_compress}" ] && dest_file="${dnsmasq_tmp_d}/.blocklist.gz"
	for src in "${src_file}" "${src_file}.gz"
	do
		case "${src}" in *.gz) src_compressed=1; esac
		[ -f "${src}" ] && { src_file="${src}"; break; }
	done || { reg_failure "Failed to find file to import."; return 1; }

	clean_dnsmasq_dir

	if [ -n "${src_compressed}" ] && [ -z "${final_compress}" ]
	then
		try_gunzip "${src_file}" || return 1
		src_file="${src_file%.gz}"
	elif [ -z "${src_compressed}" ] && [ -n "${final_compress}" ]
	then
		try_gzip "${src_file}" || return 1
		src_file="${src_file}.gz"
	fi

	try_mv "${src_file}" "${dest_file}" || return 1
	imported_final_list_size_human=$(get_file_size_human "${dest_file}")

	if [ -n "${final_compress}" ]
	then
		printf "conf-script=\"busybox sh ${dnsmasq_tmp_d}/.extract_blocklist\"\n" > "${dnsmasq_tmp_d}"/conf-script &&
		printf "busybox gunzip -c ${dnsmasq_tmp_d}/.blocklist.gz\nexit 0\n" > "${dnsmasq_tmp_d}"/.extract_blocklist ||
			{ reg_failure "Failed to create conf-script for dnsmasq."; return 1; }
	fi

	:
}

# return values:
# 0 - up-to-date
# 1 - not up-to-date
# 2 - update check failed
check_for_updates()
{
	reg_action -blue "Checking for adblock-lean updates."
	rm -f "${abl_dir}/uclient-fetch_err"
	sha256sum_adblock_lean_local=$(sha256sum "${abl_service_path}" | sed -E 's/[ \t]+.*$//')
	sha256sum_adblock_lean_remote=$(uclient-fetch https://raw.githubusercontent.com/lynxthecat/adblock-lean/master/adblock-lean -O - \
		2> "${abl_dir}/uclient-fetch_err" |
		tee >(cat > "${abl_dir}/remote_abl"; . "${abl_dir}/remote_abl" 1>/dev/null 2>/dev/null && print_def_config -d |
			get_config_format > "${abl_dir}/upd_config_format") |
		sha256sum | sed -E 's/[ \t]+.*$//')

	local bad_dl='' update_check_result=''
	read -r luci_upd_config_format _ < "${abl_dir}/upd_config_format" 2>/dev/null
	rm -f "${abl_dir}/remote_abl" "${abl_dir}/upd_config_format"

	# safeguard against receiving empty string or empty string+newline
	case "${sha256sum_adblock_lean_remote}" in *9805daca546b|*991b7852b855) bad_dl=1; esac

	if [ -z "${bad_dl}" ] && grep -q "Download completed" "${abl_dir}/uclient-fetch_err"
	then
		if [ "${sha256sum_adblock_lean_local}" = "${sha256sum_adblock_lean_remote}" ]
		then
			log_msg "The locally installed adblock-lean is the latest version."
			update_check_result=0
		else
			log_msg -yellow "The locally installed adblock-lean seems to be outdated."
			log_msg "Consider running: 'service adblock-lean update' to update it to the latest version."
			update_check_result=1
		fi
	else
		reg_failure "Unable to download latest version of adblock-lean to check for any updates."
		update_check_result=2
	fi
	rm -f "${abl_dir}/uclient-fetch_err"

	return ${update_check_result}
}

# updates the pid file with a new action
# 1 - new action
update_pid_action() {
	check_lock
	case ${?} in
		3) ;;
		1) return 1 ;;
		2) reg_failure "update_pid_action(): pid file '${pid_file}' has unexpected pid '${_pid}'."; return 1 ;;
		0) return 0
	esac
	mk_lock -f "${1}"
	return ${?}
}

# args:
# 1 - (optional) -f to skip check for existing lock
# 1/2 - action to write to the pid file
#
# return codes:
# 0 - success
# 1 - error
# 254 - lock file already exists
mk_lock()
{
	local me="mk_lock"
	if [ "${1}" != '-f' ]
	then
		check_lock
		case ${?} in
			1) return 1 ;;
			2)
				report_pid_action
				log_msg -yellow "Refusing to open another instance."
				return 254
		esac
	else
		shift
	fi

	[ -z "${1%.}" ] && { reg_failure "${me}: pid action is unspecified."; return 1; }
	[ -z "${pid_file}" ] && { reg_failure "${me}: \${pid_file} variable is unset."; return 1; }

	try_mkdir -p "${abl_pid_dir}" || return 1
	printf '%s\n' "${$} ${1%.}" > "${pid_file}" || { reg_failure "${me}: Failed to write to pid file '${pid_file}'."; return 1; }
	:
}

rm_lock()
{
	if [ -f "${pid_file}" ]
	then
		rm -f "${pid_file}" || { reg_failure "Failed to delete the pid file '${pid_file}'."; return 1; }
	fi
	:
}

# return codes:
# 0 - no lock
# 1 - error
# 2 - lock file exists and belongs to another PID
# 3 - lock file belongs to current PID
check_lock()
{
	unset _pid pid_action
	[ -z "${pid_file}" ] && { reg_failure "\${pid_file} variable is unset."; return 1; }
	[ ! -f "${pid_file}" ] && return 0
	if read -r _pid pid_action < "${pid_file}"
	then
		case "${_pid}" in
			${$}) return 3 ;;
			*[!0-9]*) reg_failure "pid file '${pid_file}' contains unexpected string."; return 1 ;;
			*) kill -0 "${_pid}" 2>/dev/null && return 2
		esac
	else
		reg_failure "Failed to read the pid file '${pid_file}'."
		return 1
	fi

	log_msg -warn "Detected stale pid file '${pid_file}'. Removing."
	rm_lock || return 1
	:
}

# kills any running adblock-lean instances
kill_abl_pids()
{
	local _killed _p _pid child_pid IFS=$'\n' k_attempt=0
	while :
	do
		k_attempt=$((k_attempt+1))
		_killed=
		for _p in $(pgrep -fa "(/etc/rc.common /etc/(rc.d/S${START}adblock-lean|init.d/adblock-lean)|luci.adblock-lean)")
		do
			_pid="${_p%% *}"
			case ${_pid} in "${$}"|*[!0-9]*) continue; esac
			kill "${_pid}" 2>/dev/null
			for child_pid in $(pgrep -P "${_pid}")
			do
				kill "${child_pid}" 2>/dev/null
			done
			_killed=1
		done
		[ -z "${_killed}" ] || [ ${k_attempt} -gt 10 ] && break
		sleep 1
	done
	:
}

# (optional) -nolog
# (optional) -[color]
# other args - action
reg_action()
{
	local msg='' nolog='' color=''
	for _arg in "$@"
	do
		case "${_arg}" in
			-nolog) nolog=1 ;;
			-blue|-red|-green|-purple|-yellow) color="${_arg}" ;;
			*) msg="${msg}${_arg} "
		esac
	done

	[ -z "${nolog}" ] && log_msg "" ${color} "${msg% }"
	if [ -n "${lock_req}" ]
	then
		update_pid_action "${msg% }" || return 1
	fi
	:
}

report_pid_action()
{
	local reported_pid="unknown PID"
	[ -n "${_pid}" ] && reported_pid="PID ${_pid}"
	: "${pid_action:="unknown action"}"
	print_msg "adblock-lean (${reported_pid}) is performing action '${pid_action}'."
	luci_pid_action=${pid_action}
	:
}

get_active_entries_cnt()
{
	local cnt entry_type allow_opt='' list_prefix list_prefixes=

	# 'blocklist_ipv4' prefix doesn't need to be added for counting
	for entry_type in blocklist allowlist
	do
		eval "[ ! \"\${${entry_type}_urls}\" ] && [ ! -s \"\${local_${entry_type}_path}\" ]" && continue
		case ${entry_type} in
			blocklist) list_prefix=local ;;
			allowlist) list_prefix=server allow_opt="#"
		esac
		list_prefixes="${list_prefixes}${list_prefix}|"
	done

	if [ -f "${dnsmasq_tmp_d}"/.blocklist.gz ]
	then
		gunzip -c "${dnsmasq_tmp_d}"/.blocklist.gz
	elif [ -f "${dnsmasq_tmp_d}"/blocklist ]
	then
		cat "${dnsmasq_tmp_d}/blocklist"
	else
		printf ''
	fi |
	sed -E "s~^(${list_prefixes%|})\=/~~;" | tr "/${allow_opt}" '\n' | wc -w > "/tmp/abl_entries_cnt"

	read -r cnt _ < "/tmp/abl_entries_cnt" || cnt=0
	rm -f "/tmp/abl_entries_cnt"
	case "${cnt}" in *[!0-9]*|'') printf 0; return 1; esac
	local d i=0 IFS="${default_IFS}"
	if [ "${whitelist_mode}" = 1 ]
	then
		i=1
		for d in ${test_domains}
		do
			i=$((i+1))
		done
	fi
	[ "${cnt}" -lt $((2+i)) ] && { printf 0; return 1; }
	printf %s "$((cnt-2-i))"
	:
}

### Cron-related functions

# args: 1 - (optional) schedule
# return codes:
# 0 - cron job with same schedule exists
# 1 - error
# 2 - cron job with a different schedule exists
# 3 - cron job doesn't exist
get_curr_crontab()
{
	local curr_cron
	curr_cron="$(crontab -u root -l 2>/dev/null)" || { reg_failure "${me}: Failed to read crontab."; return 1; }
	printf '%s\n' "${curr_cron}"

	# check if adblock-lean cron job with same schedule exists
	case "${curr_cron}" in
		*"${cron_schedule}"*"${abl_cron_cmd}"*) return 0 ;;
		*"${abl_cron_cmd}"*) return 2 ;;
		*) return 3 ;;
	esac
}

rm_cron_job()
{
	local curr_cron
	check_cron_service || return 0
	curr_cron="$(get_curr_crontab)"
	case ${?} in
		1) return 1 ;;
		3) return 0
	esac

	log_msg -purple "" "Removing cron job for adblock-lean."
	printf '%s\n' "${curr_cron}" | sed '/adblock-lean start/d;/^$/d' | crontab -u root - ||
		{ reg_failure "Failed to update crontab."; return 1; }
	:
}

# returns 0 if crontab is readable and the crond process is running, 1 otherwise
# sets $cron_reboot if above conditions are satisfied and cron is not implemented via the busybox binary
check_cron_service()
{
	# check if service is enabled
	${cron_service_path} enabled || return 1
	# check reading crontab
	crontab -u root -l &>/dev/null || return 1
	# check for crond in running processes
	pidof crond 1>/dev/null || return 1
	:
}

# checks if the cron service is enabled and running
# if not enabled or not running or if crontab doesn't exist, implements automatic correction
# return codes: 0 - success, 1 - failure
enable_cron_service()
{
	local enable_failed="Failed to enable and start the cron service"

	hash crontab || { reg_failure "${enable_failed}: 'crontab' utility is inaccessible."; return 1; }
	[ -f "${cron_service_path}" ] || { reg_failure "${enable_failed}: the cron service was not found at path '${cron_service_path}'."; return 1; }

	check_cron_service && return 0
	log_msg -warn "The cron service is not enabled or not running."

	printf '\n%s' "${purple}Attempting to enable and start the cron service...${n_c} " > "${msgs_dest}"

	# if crontab doesn't exist yet, try to create an empty crontab
	crontab -u root -l &>/dev/null || printf '' | crontab -u root -

	# try to enable and start the cron service
	${cron_service_path} enabled 1>/dev/null || ${cron_service_path} enable && { ${cron_service_path} start; sleep 2; }

	check_cron_service || { printf '%s\n' "${red}Failed.${n_c}"; reg_failure "${enable_failed}."; return 1; }
	printf '%s\n' "${green}OK${n_c}" > "${msgs_dest}"
	:
}

### Commands init

init_command()
{
	action="${1}"
	pid_file="${abl_pid_dir}/adblock-lean.pid"
	unset lock_req kill_req cleanup_req failure_msg luci_errors init_action_msg

	# detect if sourced from external RPC script for luci, depends on abl_luci_exit() being defined
	luci_sourced=
	command -v "abl_luci_exit" 1>/dev/null && luci_sourced=1

	do_dialogs=
	[ -z "${luci_skip_dialogs}" ] && [ "${msgs_dest}" = "/dev/tty" ] && do_dialogs=1

	trap 'cleanup_and_exit 1' INT TERM
	trap 'cleanup_and_exit ${?}' EXIT

	# set requirements
	case ${action} in
		help|status|gen_stats|print_log|enabled|enable|disable|upd_cron_job|'') ;;
		setup|gen_config|pause) lock_req=1 ;;
		boot|start|update|resume) cleanup_req=1 lock_req=1 ;;
		stop)
			init_action_msg="Stopping adblock-lean."
			reg_action -purple "${init_action_msg}" || exit 1
			cleanup_req=1 kill_req=1 lock_req=1 ;;
		reload|restart) reg_action -purple "Restarting adblock-lean." || exit 1 ;;
		*) reg_failure "Invalid action '${action}'."; exit 1
	esac

	# kill pids if needed
	if [ -n "${kill_req}" ]
	then
		kill_abl_pids
		check_lock
		case ${?} in
			1) exit 1 ;;
			2)
				reg_failure "Failed to kill running adblock-lean processes."
				unset lock_req cleanup_req
				exit 1
		esac
	fi

	# set dnsmasq_tmp_d
	case ${action} in boot|start|stop|status|pause|resume|update)
		dnsmasq_tmp_d="$(uci get dhcp.@dnsmasq[0].confdir 2>/dev/null)"
		: "${dnsmasq_tmp_d:=/tmp/dnsmasq.d}"
	esac

	# register lock status at init
	check_lock
	local init_lock_status=${?}

	# make lock if needed
	if [ -n "${lock_req}" ]
	then
		mk_lock "${action}" || { unset lock_req cleanup_req; exit ${?}; }
	fi

	# init session log if we have the lock
	log_file=
	case ${init_lock_status} in 0|3)
		case ${action} in
			start|boot|stop|restart|reload|pause|resume|setup) log_file="${session_log_file}" ;;
			update) log_file="${update_log_file}"
		esac
	esac

	# if creating new session, rotate the old session log file
	[ "${init_lock_status}" = 0 ] && [ -n "${log_file}" ] && [ -f "${log_file}" ] && mv "${log_file}" "${log_file}.0"

	[ -n "${init_action_msg}" ] && write_log_file "${init_action_msg}" "info"

	# create work dir, check dnsmasq, load config, source custom script
	case ${action} in
		status|boot)
			try_mkdir -p "${abl_dir}" || exit 1
			load_config || { reg_failure "Failed to load config."; exit 1; } ;;
		start|pause|resume|update)
			check_dnsmasq_instance || { [ ${?} = 1 ] && reg_failure "No running instance of dnsmasq detected."; exit 1; }
			try_mkdir -p "${abl_dir}" || exit 1
			load_config || { reg_failure "Failed to load config."; exit 1; }
			if [ -n "${custom_script}" ]
			then
				custom_scr_sourced=
				[ -f "${custom_script}" ] && . "${custom_script}" && custom_scr_sourced=1 ||
					reg_failure "Custom script '${custom_script}' doesn't exist or it returned an error."
			fi
	esac

	:
}


### MAIN COMMAND FUNCTIONS

upd_cron_job()
{
	local me="upd_cron_job" curr_cron cron_line

	log_msg -purple "" "Updating cron job for adblock-lean."

	if [ "${action}" = upd_cron_job ]
	then
		load_config || return 1
	fi

	[ -z "${cron_schedule}" ] && { reg_failure "${me}: the \$cron_schedule variable is unset."; return 1; }

	if [ "${cron_schedule}" = disable ]
	then
		log_msg -yellow "cron_schedule is set to 'disable' in config."
		rm_cron_job
		return 0
	fi

	enable_cron_service || return 1
	curr_cron="$(get_curr_crontab)"
	case ${?} in
		0) print_msg "${green}Cron job for adblock-lean with schedule '${cron_schedule}' aldready exists.${n_c}"; return 0 ;;
		1) return 1 ;;
		2) curr_cron="$(printf %s "${curr_cron}" | sed "s~^.*${abl_cron_cmd}.*\$~~")" ;; # remove cron job with a different schedule
		3) ;; # no adblock-lean cron job exists
	esac

	cron_line="${cron_schedule} RANDOM_DELAY=1 ${abl_cron_cmd} 1>/dev/null"

	#### Create new cron job
	printf '%s\n' "${curr_cron}${nl}${cron_line}" | sed '/^$/d' | crontab -u root - ||
		{ reg_failure "Failed to update crontab."; return 1; }
	log_msg "Creating cron job with schedule '${blue}${cron_schedule}${n_c}'."
	:
}

setup()
{
	setup_failed()
	{
		[ -n "${1}" ] && reg_failure "${1}"
		exit 1
	}

	get_package_name()
	{
		case "${1}" in
			awk) printf gawk ;;
			sed) printf sed ;;
			sort) printf coreutils-sort
		esac
	}

	# set all luci feedback vars to failed, unset later upon success
	luci_addnmount_failed=1 luci_service_enable_failed=1 luci_pkgs_install_failed=1 luci_cron_job_creation_failed=1

	init_command setup
	[ -z "${abl_service_path}" ] && setup_failed "\${abl_service_path} variable is unset."
	[ ! -f "${abl_service_path}" ] && setup_failed "adblock-lean service file doesn't exist at ${abl_service_path}."

	# make the script executable
	if [ ! -x "${abl_service_path}" ]
	then
		print_msg "" "${purple}Making ${abl_service_path} executable.${n_c}"
		chmod +x "${abl_service_path}" || setup_failed "Failed to make '${abl_service_path}' executable."
	else
		print_msg "" "${green}${abl_service_path} is already executable.${n_c}"
	fi

	# make addnmount entry - enables blocklist compression to reduce RAM usage
	check_addnmount
	case ${?} in
		0) print_msg "" "${green}Found existing dnsmasq addnmount UCI entry.${n_c}" ;;
		2) exit 1 ;;
		1)
			print_msg "" "${purple}Creating dnsmasq addnmount UCI entry.${n_c}"
			uci set dhcp.adblock_lean=dnsmasq &&
			uci add_list dhcp.adblock_lean.addnmount='/bin/busybox' &&
			uci commit || setup_failed "Failed to create addnmount entry."
	esac
	luci_addnmount_failed=

	REPLY=n
	if [ -n "${do_dialogs}" ] && { [ -s "${config_file}" ] || [ -s "${root_config_file}" ]; }
	then
		print_msg "" "Existing config file found." "Generate [n]ew config or use [e]xisting config?"
		pick_opt 'n|e' || exit 1
	elif [ -n "${luci_use_old_config}" ]
	then
		REPLY=e
	fi

	if [ "${REPLY}" = n ]
	then
		# generate config
		gen_config || exit 1
	else
		load_config || exit 1
	fi

	# enable the service, update the cron job
	/sbin/service adblock-lean enable || setup_failed
	luci_service_enable_failed=

	# determine if there are missing GNU utils
	local pkgs2install='' missing_packages='' missing_utils='' missing_utils_print='' util package \
		util_size_B utils_size_B=0 awk_size_B=1048576 sort_size_B=122880 sed_size_B=153600 \
		installed_utils="$(opkg list_installed | grep -E '^[ \t]*(sed|gawk|coreutils-sort)([ \t]|$)')"

	echo
	for util in sed sort awk
	do
		case "${installed_utils}" in
			*"${util}"*) print_msg "${green}GNU ${util} is already installed.${n_c}" ;;
			*)
				missing_utils="${missing_utils}${util} "
				missing_utils_print="${missing_utils_print}${blue}GNU ${util}${n_c}, "
				missing_packages="${missing_packages}${blue}$(get_package_name "${util}")${n_c}, "
		esac
	done

	# make a list of GNU utils to install
	if [ -n "${missing_utils}" ]
	then
		local free_space_B='' free_space_KB="$(df -k /usr/ | tail -n1 | sed -E 's/^[ \t]*([^ \t]+[ \t]+){3}//;s/[ \t]+.*//')" \
			mount_point="$(df -k /usr/ | tail -n1 | sed -E 's/.*[ \t]+//')"
		case "${free_space_KB}" in
			''|*[!0-9]*) reg_failure "Failed to check available free space." ;;
			*) free_space_B=$((free_space_KB*1024))
		esac

		if [ -n "${do_dialogs}" ] 
		then
			print_msg "" "For improved performance while processing the lists, it is recommended to install ${missing_utils_print%, }." \
				"Corresponding opkg packages are: ${missing_packages%, }."
			[ -n "${free_space_B}" ] &&
				print_msg "" "Available free space at mount point '${mount_point}': ${yellow}$(bytes2human "${free_space_B}")${n_c}." ""
		fi

		for util in ${missing_utils}
		do
			REPLY=n
			if [ -n "${do_dialogs}" ]
			then
				eval "util_size_B=\"\${${util}_size_B}\""
				print_msg "Would you like to install ${blue}GNU ${util}${n_c} automatically? Installed size: ${yellow}$(bytes2human "${util_size_B}")${n_c}."
				pick_opt "y|n" || exit 1
			elif [ -n "${luci_install_packages}" ]
			then
				REPLY=y
			fi

			if [ "${REPLY}" = y ]
			then
				pkgs2install="${pkgs2install}$(get_package_name "${util}") "
				utils_size_B=$((utils_size_B+util_size_B))
			fi
		done
	fi

	# install GNU utils
	if [ -n "${pkgs2install}" ]
	then
		REPLY=n
		if [ -n "${do_dialogs}" ]
		then
			print_msg "" "Selected packages: ${blue}${pkgs2install% }${n_c}" \
				"Total installed size: ${yellow}$(bytes2human ${utils_size_B})${n_c}." \
				"Proceed with packages installation?"
			pick_opt "y|n"
		elif [ -n "${luci_install_packages}" ]
		then
			REPLY=y
		fi

		if [ "${REPLY}" = y ]
		then
			if [ -z "${free_space_B}" ] || [ -z "${utils_size_B}" ] || [ ${free_space_B} -gt ${utils_size_B} ]
			then
				echo
				opkg update && opkg install ${pkgs2install% } && luci_pkgs_install_failed='' ||
					reg_failure "Failed to automatically install packages. You can install them manually later."
			else
				reg_failure "Not enough free space at mount point '${mount_point}'."
				print_msg "Free up some space, then you can manually install the packages later by issuing the command:" \
					"opkg update; opkg install ${pkgs2install% }"
			fi
		fi
	else
		luci_pkgs_install_failed=
	fi

	if [ -n "${do_dialogs}" ]
	then
		print_msg "" "${purple}Setup is complete.${n_c}" "" "Start adblock-lean now?"
		pick_opt "y|n" || exit 1
		[ "${REPLY}" != y ] && return 0
		echo
		start
	fi
	:
}

print_log()
{
	[ ! -s "${session_log_file}" ] && { log_msg -err "Session log file '${session_log_file}' doesn't exist or is empty."; exit 1; }
	echo "Most recent session log:"
	cat "${session_log_file}"
	:
}

# 1 - (optional) '-noexit' to return to the calling function
gen_stats()
{
	reg_action -blue "Generating dnsmasq stats." || exit 1
	local dnsmasq_pid
	dnsmasq_pid="$(pidof /usr/sbin/dnsmasq)" || { reg_failure "Failed to detect dnsmasq PID or dnsmasq is not running."; exit 1; }
	kill -USR1 "${dnsmasq_pid}"
	print_msg "dnsmasq stats available for reading using 'logread'."
	[ "${1}" != '-noexit' ] && exit 0
}

# generates config
gen_config()
{
	init_command gen_config || return 1

	local cnt

	if [ -n "${do_dialogs}" ] && [ -z "${luci_preset}" ]
	then
		mk_preset_arrays
		mk_def_preset || print_msg "Skipping automatic preset recommendation."
		if [ -n "${preset}" ]
		then
			print_msg "" "Based on the total usable memory of this device ($(bytes2human $((totalmem*1024)) )), the recommended preset is '${purple}${preset}${n_c}':"
			gen_preset "${preset}"
			print_msg "" "[C]onfirm this preset or [p]ick another preset?"
			pick_opt "c|p"
		else
			REPLY=p
		fi

		if [ "${REPLY}" = p ]
		then
			print_msg "" "${purple}All available presets:${n_c}"
			for preset in mini small medium large
			do
				gen_preset "${preset}" -d
			done
			print_msg "" "Pick preset:"
			pick_opt "mini|small|medium|large"
			preset="${REPLY}"
		fi
	else
		[ "${luci_preset}" != auto ] && preset="${luci_preset}"
	fi

	[ -z "${preset}" ] && { reg_failure "No config preset was selected."; return 1; }

	# create cron job
	cron_schedule=
	local def_schedule="0 5 * * *" def_schedule_desc="daily at 5am (5 o'clock at night)"

	REPLY=n
	if [ -n "${do_dialogs}" ]
	then
		print_msg "" "${purple}Cron job configuration:${n_c}" \
			"A cron job can be created to enable automatic list updates." \
			"The default schedule is '${blue}${def_schedule}${n_c}': ${def_schedule_desc}" \
			"The cron job will run with an added random number of minutes." \
			"" "Create cron job with default schedule for automatic list updates?" \
			"'n' will set the 'cron_schedule' setting to 'disable'. You can later create a cron job with a custom schedule as described in:" \
			"https://github.com/lynxthecat/adblock-lean/blob/master/README.md"
		pick_opt "y|n" || return 1
		cron_schedule="${def_schedule}"
	elif [ -n "${luci_upd_cron_job}" ] && [ -n "${luci_cron_schedule}" ]
	then
		REPLY=y
		cron_schedule="${luci_cron_schedule}"
	elif  [ -n "${luci_upd_cron_job}" ]
	then
		reg_failure "Can not create cron job for luci because the \${luci_cron_schedule} var is empty."
	fi
	[ "${REPLY}" = n ] && cron_schedule=disable

	reg_action -purple "Generating new default config for adblock-lean from preset '${preset}'." || return 1
	if [ -n "${do_dialogs}" ] && [ -f "${config_file}" ]
	then
		print_msg "This will overwrite existing config. Proceed?"
		pick_opt "y|n" || return 1
		[ "${REPLY}" = n ] && return 1
	fi
	write_config "$(print_def_config -p "${preset}")" || return 1

	mk_new_urls_format_flag || return 1 # @url_conversion_logic

	check_blocklist_compression_support
	:
}

boot()
{
	init_command boot || exit 1
	log_msg -purple "Sleeping for ${boot_start_delay_s} seconds." || exit 1
	sleep "${boot_start_delay_s}"
	start "$@"
}

start()
{
	init_command start || exit 1
	log_msg -purple "Started adblock-lean." ""

	if type gawk &> /dev/null
	then
		log_msg "gawk detected so using gawk for fast (sub)domain match removal and entries packing."
		awk_cmd="gawk"
	else
		log_msg -yellow "gawk not detected so allowlist (sub)domains removal from blocklist will be slow and list processing will not be as efficient."
		log_msg "Consider installing the gawk package 'opkg install gawk' for faster processing and (sub)domain match removal."
		awk_cmd="awk"
	fi

	if sed --version 2>/dev/null | grep -qe '(GNU sed)'
	then
		log_msg "GNU sed detected so list processing will be fast."
	else
		log_msg -yellow "GNU sed not detected so list processing will be a little slower."
		log_msg "Consider installing the GNU sed package (opkg install sed) for faster processing."
	fi

	if sort --version 2>/dev/null | grep -qe coreutils
	then
		log_msg "coreutils-sort detected so sort will be fast."
	else
		log_msg -yellow "coreutils-sort not detected so sort will be a little slower."
		log_msg "Consider installing the coreutils-sort package (opkg install coreutils-sort) for faster sort."
	fi

	final_compress=
	if [ "${use_compression}" = 1 ]
	then
		check_blocklist_compression_support
		case ${?} in
			0) final_compress=1 ;;
			2) exit 1
		esac
	fi

	if [ "${RANDOM_DELAY}" = "1" ]
	then
		random_delay_mins=$(($(hexdump -n 1 -e '"%u"' </dev/urandom)%60))
		reg_action -purple "Delaying adblock-lean by: ${random_delay_mins} minutes (thundering herd prevention)." || exit 1
		sleep "${random_delay_mins}m"
	fi

	try_export_existing_blocklist
	[ ${?} = 1 ] && exit 1

	if [ "${initial_dnsmasq_restart}" != 1 ]
	then
		reg_action -blue "Testing connectivity." || exit 1
		test_url_domains || initial_dnsmasq_restart=1
	fi

	if [ "${initial_dnsmasq_restart}" = 1 ]
	then
		clean_dnsmasq_dir
		restart_dnsmasq || exit 1
	fi

	initial_uptime_ms=$(get_uptime_ms)

	if ! gen_list_parts
	then
		reg_failure "Failed to generate preprocessed blocklist file with at least one entry."
		restore_saved_blocklist || stop 1
		exit 1
	fi

	log_msg -green "" "Successfully generated preprocessed blocklist file with $(int2human ${preprocessed_list_line_cnt}) entries."

	if ! generate_and_process_blocklist_file
	then
		reg_failure "New blocklist file check failed."
		restore_saved_blocklist || stop 1
		exit 1
	fi

	if ! import_blocklist_file
	then
		reg_failure "Failed to import new blocklist file."
		restore_saved_blocklist || stop 1
		exit 1
	fi

	compressed=
	[ -n "${final_compress}" ] && compressed=" compressed"
	log_msg "" "Successfully imported new${compressed} blocklist file for use by dnsmasq with size: ${imported_final_list_size_human}."

	restart_dnsmasq || exit 1

	elapsed_time_str=$(get_elapsed_time_str)
	log_msg "" "Processing time for blocklist generation and import: ${elapsed_time_str}."

	if ! check_active_blocklist
	then
		reg_failure "Active blocklist check failed with new blocklist file."
		restore_saved_blocklist || stop 1

		check_active_blocklist || { reg_failure "Active blocklist check failed with previous blocklist file."; stop 1; }

		log_msg -green "Previous blocklist restored and dnsmasq check passed."
		exit 1
	fi

	log_msg -green "Active blocklist check passed with the new blocklist file."
	log_success "New blocklist installed with entries count: $(int2human "${final_entries_cnt}")."
	rm -f "${abl_dir}/prev_blocklist.gz"

	check_for_updates
	exit 0
}

# 1 - (optional) exit code
# 1/2 - (optional) '-noexit' to return to the calling function
stop()
{
	local stop_rc=0 noexit=
	for _arg in "$@"
	do
		case "${_arg}" in
			"-noexit") noexit=1 ;;
			*[!0-9]*|'') ;;
			*) stop_rc="${_arg}"
		esac
	done
	msg="${msg% }"

	init_command stop || exit 1
	log_msg "Removing any adblock-lean blocklist files in ${dnsmasq_tmp_d}." || exit 1
	clean_dnsmasq_dir
	restart_dnsmasq || stop_rc=1
	log_msg -purple "" "Stopped adblock-lean." ""
	[ -n "$noexit" ] && return "${stop_rc}"
	exit "${stop_rc}"
}

restart()
{
	init_command restart || exit 1
	stop -noexit || exit 1
	start
}

reload()
{
	restart
}

# return codes:
# 0 - adblock-lean blocklist is loaded
# 1 - error
# 2 - adblock-lean is performing an action
# 3 - adblock-lean is paused
# 4 - adblock-lean is stopped
status()
{
	init_command status || exit 1
	check_lock
	case ${?} in
		1) exit 1 ;;
		2)
			report_pid_action
			exit 2
	esac
	get_abl_run_state
	case ${?} in
		0) ;;
		3) log_msg -purple "adblock-lean is currently paused."; exit 3 ;;
		4) log_msg -purple "adblock-lean is stopped."; exit 4;
	esac
	check_active_blocklist; local dnsmasq_status=${?}
	luci_dnsmasq_status=${dnsmasq_status}

	local active_entries_cnt=0

	if [ ${dnsmasq_status} = 0 ]
	then
		active_entries_cnt="$(get_active_entries_cnt)" || reg_failure "No entries found in the blocklist file."

		luci_good_line_count=${active_entries_cnt}
		log_msg "The dnsmasq check passed and the presently installed blocklist has entries count: $(int2human ${active_entries_cnt})."
		log_msg -green "adblock-lean is active."
		gen_stats -noexit
	else
		reg_failure "The dnsmasq check failed with existing blocklist file."
		log_msg "Consider a full reset by running: 'service adblock-lean restart'."
	fi
	check_for_updates
	luci_update_status=${?}

	[ ${dnsmasq_status} = 0 ] && [ ${active_entries_cnt} != 0 ] && exit 0
	exit 1
}

pause()
{
	init_command pause || exit 1
	get_abl_run_state
	case ${?} in
		0) ;;
		3) log_msg -err "adblock-lean is already paused."; exit 1 ;;
		4) log_msg -err "adblock-lean is currently stopped."; exit 1;
	esac
	reg_action -purple "Pausing adblock-lean." || exit 1
	try_export_existing_blocklist || exit 1
	restart_dnsmasq || exit 1
	log_msg -purple "adblock-lean is now paused."
	exit 0
}

resume()
{
	init_command resume || exit 1
	get_abl_run_state
	case ${?} in
		0) log_msg -err "adblock-lean is already running."; exit 1 ;;
		3) ;;
		4) log_msg -err "adblock-lean is currently stopped, not paused. Can not resume."; exit 1;
	esac

	reg_action -purple "Resuming adblock-lean." || exit 1
	restore_saved_blocklist || stop 1
	restart_dnsmasq || stop 1
	log_msg -purple "adblock-lean is now resumed."
	exit 0
}

# 1 - (optional) '-no-check-config' to skip checking config compatibility with the newer version
# 1 - (optional) '--simulation <path>' to simulate update (intended for testing: service adblock-lean update --simulation <path_to_new_ver>)
update()
{
	failsafe_log()
	{
		printf '%s\n' "${1}" > "${msgs_dest:-/dev/tty}"
		logger -t adblock-lean "${1}"
	}

	init_command update || exit 1
	reg_action -purple "Obtaining latest version of adblock-lean." || exit 1

	if [ "${1}" != "--simulation" ]
		then
		uclient-fetch https://raw.githubusercontent.com/lynxthecat/adblock-lean/master/adblock-lean \
			-O "${abl_dir}/adblock-lean.latest" 1> /dev/null 2> "${abl_dir}/uclient-fetch_err"
		if ! grep -q "Download completed" "${abl_dir}/uclient-fetch_err"
		then
			reg_failure "Unable to download latest version of adblock-lean."
			rm -f "${abl_dir}/adblock-lean.latest" "${abl_dir}/uclient-fetch_err"
			exit 1
		fi
	else
		print_msg "${yellow}Running in simulation mode.${n_c}"
		[ -z "${2}" ] && { print_msg "${red}Provide path to the new version.${n_c}"; exit 1; }
		cp "${2}" "${abl_dir}/adblock-lean.latest"
	fi

	if [ "${1}" != '-no-check-config' ]
	then
		(
			prev_config_format="${curr_config_format}"
			. "${abl_dir}/adblock-lean.latest" || exit 1
			command -v print_def_config && command -v get_config_format && upd_config_format="$(print_def_config | get_config_format)"
			if [ -n "${upd_config_format}" ] && [ -n "${prev_config_format}" ] && [ "${upd_config_format}" != "${prev_config_format}" ]
			then
				failsafe_log "NOTE: config format has changed."
				if command -v load_config
				then
					load_config
				else
					failsafe_log "Please run 'service adblock-lean start' to initialize the new config."
				fi
			fi
			:
		) 1>/dev/null ||
		{
			reg_failure "Failed to source the downloaded file. Canceling the update."
			rm -f "${abl_dir}/adblock-lean.latest"
			exit 1
		}
	fi

	if [ "${1}" != "--simulation" ]
	then
		try_mv "${abl_dir}/adblock-lean.latest" "${abl_service_path}" || exit 1
		chmod +x "${abl_service_path}"
		${abl_service_path} enable
	fi
	log_msg -green "adblock-lean has been updated to the latest version."

	rm -f "${abl_dir}/adblock-lean.latest" "${abl_dir}/uclient-fetch_err"
	exit 0
}

uninstall()
{
	log_msg -purple "" "Uninstalling adblock-lean."
	stop -noexit
	if /sbin/service adblock-lean enabled &>/dev/null
		then
		log_msg -purple "" "Disabling adblock-lean."
		disabling=1 /sbin/service adblock-lean disable && ! /sbin/service adblock-lean enabled ||
			{ reg_failure "Failed to disable adblock-lean. Disable manually and then run this command again."; exit 1; }
	fi

	if [ -n "${do_dialogs}" ]
	then
		print_msg "" "Delete the config directory ${config_dir}?"
		pick_opt "y|n"
	else
		REPLY="${luci_uninstall_rm_config}"
	fi

	if [ "${REPLY}" = y ]
	then
		log_msg -purple "" "Deleting the config directory."
		rm -rf "${config_dir}" || reg_failure "Failed to delete the config directory '${config_dir}'."
	fi

	if uci -q get dhcp.adblock_lean 1>/dev/null
	then
		log_msg -purple "" "Deleting the custom addnmount entry from /etc/config/dhcp."
		uci -q delete dhcp.adblock_lean && uci commit || reg_failure "Failed to delete the custom addnmount entry from /etc/config/dhcp."
	fi

	log_msg -purple "" "Deleting the script from ${abl_service_path}."
	rm -f "${abl_service_path}" ||
		{ reg_failure "Failed to delete the script from '${abl_service_path}'. Please delete manually."; exit 1; }

	log_msg -purple "" "Uninstall complete."
	exit 0
}

set_colors

case "${1}" in
	setup) setup; exit 0 ;;
	uninstall) uninstall; exit 0
esac

# handle enable/disable actions
case "${action}" in
	enable)
		if ! [ "${enabling}" ]
		then
			export enabling=1
			if ! /sbin/service adblock-lean enabled
			then
				log_msg -purple "" "Enabling the adblock-lean service."
				/sbin/service adblock-lean enable && /sbin/service adblock-lean enabled ||
					{ reg_failure "Failed to enable the adblock-lean service"; exit 1; }
			else
				log_msg -green "The adblock-lean service is already enabled."
				exit 0
			fi
			load_config
			if [ -n "${cron_schedule}" ] && [ "${cron_schedule}" != disable ]
			then
				upd_cron_job && luci_cron_job_creation_failed=
			else
				luci_cron_job_creation_failed=
			fi
		fi ;;
	disable)
		if [ -z "${disabling}" ]
		then
			export disabling=1
			if enabled
			then
				log_msg -purple "Disabling adblock-lean."
				load_config && rm_cron_job
				disable && ! enabled ||
					{ reg_failure "Failed to disable the adblock-lean service"; exit 1; }
				stop -noexit
			else
				log_msg "The adblock-lean service is already disabled."
			fi
			exit 0
		fi
esac
:
